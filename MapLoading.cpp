#include "common.h"
#include "GUI.h"
#include "MapLoading.h"
#include "WorldSegment.h"
#include "SpriteMaps.h"
#include "Constructions.h"
#include "GameBuildings.h"
#include "Creatures.h"
#include "ContentLoader.h"
#include "Occlusion_Test.h"
#include <df/plant.h>
#include <df/flow_info.h>
#include "df/item_constructed.h"
#include "df/itemimprovement.h"
#include "df/itemimprovement_threadst.h"
#include "df/item_threadst.h"
/*
static DFHack::Core* pDFApiHandle = 0;
static DFHack::Process * DFProc = 0;
const VersionInfo *dfMemoryInfo;
bool memInfoHasBeenRead;*/
bool connected = 0;
bool threadrunnng = 0;
segParams parms;


inline bool IDisWall(int in){
    //if not a custom type, do a lookup in dfHack's interface
    return isWallTerrain( (tiletype::tiletype) in );
}

inline bool IDisFloor(int in){
    //if not a custom type, do a lookup in dfHack's interface
    return isFloorTerrain( (tiletype::tiletype) in );;
}

//big look up table
char rampblut[] =
// generated by blutmaker.py
{
	1 ,  2 ,  8 ,  2 ,  4 , 12 ,  4 , 12 ,  9 ,  2 , 21 ,  2 ,  4 , 12 ,  4 , 12 ,
	5 , 16 ,  5 , 16 , 13 , 13 , 13 , 12 ,  5 , 16 ,  5 , 16 , 13 , 13 , 13 , 16 ,
	7 ,  2 , 14 ,  2 ,  4 , 12 ,  4 , 12 , 20 , 26 , 25 , 26 ,  4 , 12 ,  4 , 12 ,
	5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,
	3 , 10 ,  3 , 10 , 17 , 12 , 17 , 12 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 10 , 11 , 16 , 11 , 26 , 17 , 12 , 11 , 16 , 11 , 16 , 13 , 13 , 17 , 16 ,
	3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 11 , 11 , 16 , 11 , 11 , 17 , 14 , 11 , 16 , 11 , 16 , 17 , 17 , 17 , 13 ,
	6 ,  2 , 19 ,  2 ,  4 , 12 ,  4 , 12 , 15 ,  2 , 24 ,  2 ,  4 , 12 ,  4 , 12 ,
	5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
	18 ,  2 , 22 ,  2 , 26 , 12 , 26 , 12 , 23 , 26 , 26 , 26 , 26 , 12 , 26 , 12 ,
	5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
	3 , 10 ,  3 , 10 , 17 , 10 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 10 , 11 , 16 , 17 , 10 , 17 , 17 , 11 , 16 , 11 , 16 , 17 , 15 , 17 , 12 ,
	3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 16 , 11 , 16 , 17 , 16 , 17 , 10 , 11 , 16 , 11 , 16 , 17 , 11 , 17 , 26
};

inline bool isBlockHighRampEnd(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
	Block* block = segment->getBlockRelativeTo( x, y, z, dir);
	if(!block) return false;
	if(block->tileShapeBasic!=tiletype_shape_basic::Wall) return false;
	return IDisWall( block->tileType );
}

inline int blockWaterDepth(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
	Block* block = segment->getBlockRelativeTo( x, y, z, dir);
	if(!block) return false;
	if(block->water.index == 0 || block->water.type == 1) return false;
	return block->water.index;
}

inline bool isBlockHighRampTop(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
	Block* block = segment->getBlockRelativeTo( x, y, z, dir);
	if(!block) return false;
	if(block->tileShapeBasic!=tiletype_shape_basic::Floor && block->tileShapeBasic!=tiletype_shape_basic::Ramp && block->tileShapeBasic!=tiletype_shape_basic::Stair) return false;
	if(block->tileShapeBasic!=tiletype_shape_basic::Wall) return true;
	return !IDisWall( block->tileType );
}

int CalculateRampType(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment){
	int ramplookup = 0;
	if (isBlockHighRampEnd(x, y, z, segment, eUp) && isBlockHighRampTop(x, y, z+1, segment, eUp))
		ramplookup ^= 1;
	if (isBlockHighRampEnd(x, y, z, segment, eUpRight) && isBlockHighRampTop(x, y, z+1, segment, eUpRight))
		ramplookup ^= 2;
	if (isBlockHighRampEnd(x, y, z, segment, eRight) && isBlockHighRampTop(x, y, z+1, segment, eRight))
		ramplookup ^= 4;
	if (isBlockHighRampEnd(x, y, z, segment, eDownRight) && isBlockHighRampTop(x, y, z+1, segment, eDownRight))
		ramplookup ^= 8;
	if (isBlockHighRampEnd(x, y, z, segment, eDown) && isBlockHighRampTop(x, y, z+1, segment, eDown))
		ramplookup ^= 16;
	if (isBlockHighRampEnd(x, y, z, segment, eDownLeft) && isBlockHighRampTop(x, y, z+1, segment, eDownLeft))
		ramplookup ^= 32;
	if (isBlockHighRampEnd(x, y, z, segment, eLeft) && isBlockHighRampTop(x, y, z+1, segment, eLeft))
		ramplookup ^= 64;
	if (isBlockHighRampEnd(x, y, z, segment, eUpLeft) && isBlockHighRampTop(x, y, z+1, segment, eUpLeft))
		ramplookup ^= 128;

	// creation should ensure in range
	if (ramplookup > 0)
	{
		return rampblut[ramplookup];
	}

	if (isBlockHighRampEnd(x, y, z, segment, eUp))
		ramplookup ^= 1;
	if (isBlockHighRampEnd(x, y, z, segment, eUpRight))
		ramplookup ^= 2;
	if (isBlockHighRampEnd(x, y, z, segment, eRight))
		ramplookup ^= 4;
	if (isBlockHighRampEnd(x, y, z, segment, eDownRight))
		ramplookup ^= 8;
	if (isBlockHighRampEnd(x, y, z, segment, eDown))
		ramplookup ^= 16;
	if (isBlockHighRampEnd(x, y, z, segment, eDownLeft))
		ramplookup ^= 32;
	if (isBlockHighRampEnd(x, y, z, segment, eLeft))
		ramplookup ^= 64;
	if (isBlockHighRampEnd(x, y, z, segment, eUpLeft))
		ramplookup ^= 128;

	// creation should ensure in range
	return rampblut[ramplookup];
}

bool isBlockOnVisibleEdgeOfSegment(WorldSegment* segment, Block* b)
{
	if(b->z == segment->z + segment->sizez - 2) 
		return true;

	if(!(segment->getBlock(b->x, b->y, b->z+1)))
		return true;

	if (DisplayedRotation == 0 && 
		(
		b->x == segment->x + segment->sizex - 2
		|| b->y == segment->y + segment->sizey - 2
		|| b->x == segment->regionSize.x - 1
		|| b->y == segment->regionSize.y - 1
		))
	{
		return true;
	}
	else if (DisplayedRotation == 1 &&
		(
		b->x == segment->x + segment->sizex - 2
		|| b->y == segment->y + 1
		|| b->x == segment->regionSize.x - 1
		|| b->y == 0
		))
	{
		return true;
	}
	else if (DisplayedRotation == 2 &&
		(
		b->x == segment->x + 1
		|| b->y == segment->y + 1
		|| b->x == 0
		|| b->y == 0
		))
	{
		return true;
	}
	else if (DisplayedRotation == 3 && 
		(
		b->x == segment->x + 1
		|| b->y == segment->y + segment->sizey - 2
		|| b->x == 0
		|| b->y == segment->regionSize.y - 1
		))
	{
		return true;
	}

	return false;
}

bool areNeighborsVisible(t_designation designations[16][16],int  x,int y)
{
	if(designations[x-1][y-1].bits.hidden == false)
		return true;
	if(designations[x-1][y].bits.hidden == false)
		return true;
	if(designations[x-1][y+1].bits.hidden == false)
		return true;
	if(designations[x][y-1].bits.hidden == false)
		return true;
	if(designations[x][y+1].bits.hidden == false)
		return true;
	if(designations[x+1][y-1].bits.hidden == false)
		return true;
	if(designations[x+1][y].bits.hidden == false)
		return true;
	if(designations[x+1][y+1].bits.hidden == false)
		return true;
	return false;
}

void ReadCellToSegment(DFHack::Core& DF, WorldSegment& segment, int CellX, int CellY, int CellZ,
					   uint32_t BoundrySX, uint32_t BoundrySY,
					   uint32_t BoundryEX, uint32_t BoundryEY, 
					   uint16_t Flags/*not in use*/, 
                       vector<Buildings::t_building>* allBuildings, 
					   vector<df::construction>* allConstructions,
					   vector< vector <int16_t> >* allLayers)
{
	if(config.skipMaps)
		return;
	//boundry check
	int cellDimX, cellDimY, cellDimZ;
	Maps::getSize((unsigned int &)cellDimX, (unsigned int &)cellDimY, (unsigned int &)cellDimZ);
	if( CellX < 0 || CellX >= cellDimX ||
		CellY < 0 || CellY >= cellDimY ||
		CellZ < 0 || CellZ >= cellDimZ ) 
		return;
	if(!Maps::getBlock(CellX, CellY, CellZ))
		return;


	//make boundries local
	BoundrySX -= CellX * CELLEDGESIZE;
	BoundryEX -= CellX * CELLEDGESIZE;
	BoundrySY -= CellY * CELLEDGESIZE;
	BoundryEY -= CellY * CELLEDGESIZE;


	//read cell data
	df::map_block *trueBlock;
	trueBlock = Maps::getBlock(CellX, CellY, CellZ);

	//read local vein data
    vector <df::block_square_event_mineralst * > veins;
    vector <df::block_square_event_frozen_liquidst * > ices;
    vector <df::block_square_event_material_spatterst * > splatter;
    vector <df::block_square_event_grassst * > grass;
    vector <df::block_square_event_world_constructionst * > worldconstructions;
	Maps::SortBlockEvents(
		trueBlock,
		&veins,
		&ices,
		&splatter,
		&grass,
		&worldconstructions);

	uint32_t numVeins = (uint32_t)veins.size();

	//parse cell
	for(uint32_t ly = BoundrySY; ly <= BoundryEY; ly++)
	{
		for(uint32_t lx = BoundrySX; lx <= BoundryEX; lx++){
			uint32_t gx = lx + (CellX * CELLEDGESIZE);
			uint32_t gy = ly + (CellY * CELLEDGESIZE);
			if( !segment.CoordinateInsideSegment( gx, gy, CellZ) )
			{ 
				continue;
			}
			bool createdBlock = false;
			Block* b = segment.getBlock( gx, gy, CellZ);

			if (!b)
			{
				createdBlock = true;
				b = new Block ( &segment );
				b->x = gx;
				b->y = gy;
				b->z = CellZ;
			}

			b->occ = trueBlock->occupancy[lx][ly];
			b->designation = trueBlock->designation[lx][ly];
			b->mudlevel = 0;
			b->snowlevel = 0;
			b->bloodlevel = 0;
			b->grasslevel = 0;
			b->grassmat = -1;
			//b->grasslevels.clear();
			//b->grassmats.clear();
			for(int i = 0; i < grass.size(); i++)
			{
				if(grass[i]->amount[lx][ly] > 0 && b->grasslevel == 0)//b->grasslevel)
				{
					b->grasslevel = grass[i]->amount[lx][ly];
					b->grassmat = grass[i]->plant_index;
					//b->grasslevels.push_back(grass[i].intensity[lx][ly]);
					//b->grassmats.push_back(grass[i].material);
				}
			}
			if(1)// just in case we need to quickly disable it.
			{
				long red=0;
				long green=0;
				long blue=0;
				long bloodlevel=0;
				for(int i = 0; i < splatter.size(); i++)
				{
					if(!splatter[i]->amount[lx][ly])
						continue;
					uint8_t level = (uint8_t)splatter[i]->amount[lx][ly];
					if(splatter[i]->mat_type == MUD)
					{
						b->mudlevel = level;
					}
					else if(splatter[i]->mat_type == ICE)
					{
						b->snowlevel = level;
					}
					else if(splatter[i]->mat_type == VOMIT)
					{
						bloodlevel += level;
                        red += (127 * level);
                        green += (196 * level);
                        blue += (28 *level);
					}
                    else if(splatter[i]->mat_type > 19)
					{
						MaterialInfo mat;
						mat.decode(splatter[i]->mat_type, splatter[i]->mat_index);
                        bloodlevel += level;
                        red += (contentLoader->Mats->color[mat.material->state_color[splatter[i]->mat_state]].red * level * 255);
						green += (contentLoader->Mats->color[mat.material->state_color[splatter[i]->mat_state]].green * level * 255);
                        blue += (contentLoader->Mats->color[mat.material->state_color[splatter[i]->mat_state]].blue * level * 255);
					}
				}
				if(bloodlevel < 0)
					bloodlevel = 0-bloodlevel;
				b->bloodlevel = bloodlevel;
				if(bloodlevel)
				{
				b->bloodcolor = al_map_rgba(red/b->bloodlevel, green/b->bloodlevel, blue/b->bloodlevel, (bloodlevel > config.bloodcutoff) ? 255 : bloodlevel*255/config.bloodcutoff);
				}
				else
					b->bloodcolor = al_map_rgba(0,0,0,0);
			}
			else
			{
				b->bloodcolor = al_map_rgb(150, 0, 24);
			}
			//temperatures

			b->temp1 = trueBlock->temperature_1[lx][ly];
			b->temp2 = trueBlock->temperature_2[lx][ly];
			//liquids
			if(trueBlock->designation[lx][ly].bits.flow_size > 0){
				b->water.type  = trueBlock->designation[lx][ly].bits.liquid_type;
				b->water.index = trueBlock->designation[lx][ly].bits.flow_size;
			}

            //read tiletype
            b->tileType = trueBlock->tiletype[lx][ly];
            b->tileShape = tileShape(b->tileType);
            b->tileShapeBasic = tileShapeBasic(b->tileShape);
            b->tileSpecial = tileSpecial(b->tileType);
            b->tileMaterial = tileMaterial(b->tileType);

			//142,136,15
			//if(b->x == 142 && b->y == 136 && b->z == 15)
			//  int j = 10;

			//save in segment
			bool isHidden = trueBlock->designation[lx][ly].bits.hidden;
			//option for including hidden blocks
			isHidden &= !config.show_hidden_blocks;
			bool shouldBeIncluded = (!isOpenTerrain(b->tileType) || b->water.index || !trueBlock->designation[lx][ly].bits.outside) && !isHidden;

			//include hidden blocks as shaded black 
			if(config.shade_hidden_blocks && isHidden && (isBlockOnVisibleEdgeOfSegment(&segment, b) || areNeighborsVisible(trueBlock->designation, lx, ly)))
			{
				b->building.info.type = (building_type::building_type) BUILDINGTYPE_BLACKBOX;
				shouldBeIncluded= true;
			}

			if( shouldBeIncluded )
			{
				//this only needs to be done for included blocks

				//determine rock/soil type
				int rockIndex = -1;
				if(trueBlock->region_offset[trueBlock->designation[lx][ly].bits.biome] < (*allLayers).size())
					if(trueBlock->designation[lx][ly].bits.geolayer_index < (*allLayers).at(trueBlock->region_offset[trueBlock->designation[lx][ly].bits.biome]).size())
						rockIndex = (*allLayers).at(trueBlock->region_offset[trueBlock->designation[lx][ly].bits.biome]).at(trueBlock->designation[lx][ly].bits.geolayer_index);
				b->layerMaterial.type = INORGANIC;
				b->layerMaterial.index = rockIndex;
				//check veins
				//if there's no veins, the vein material should just be the layer material.
				b->veinMaterial.type = INORGANIC;
				b->veinMaterial.index = rockIndex;
				for(uint32_t i=0; i<numVeins; i++)
				{
					//TODO: This will be fixed in dfHack at some point, but right now objects that arnt veins pass through as. So we filter on vtable

					//if((uint32_t)veins[i].type >= groundTypes.size())
					//continue;

					// DANGER: THIS CODE MAY BE BUGGY
					// This was apparently causing a crash in previous version
					// But works fine for me
					uint16_t row = veins[i]->tile_bitmask[ly];
					bool set = (row & (1 << lx)) != 0;
					if(set){
						rockIndex = veins[i]->inorganic_mat;
						b->veinMaterial.type = INORGANIC;
						b->veinMaterial.index = veins[i]->inorganic_mat;
						b->hasVein = 1;
					}
					else
					{
						b->veinMaterial.type = INORGANIC;
						b->veinMaterial.index = rockIndex;
					}
				}
				b->material.type = INORGANIC;
				b->material.index = b->veinMaterial.index;

                //read global/local features
                int16_t idx = trueBlock->global_feature;
                t_feature local, global;
                Maps::ReadFeatures(CellX,CellY,CellZ,&local,&global);
                if( idx != -1 && global.type != -1 && global.main_material != -1)
                {
                    if(trueBlock->designation[lx][ly].bits.feature_global)
                    {
                        //if(global_features->at(idx).main_material == INORGANIC) // stone
                        //{
                        //there may be other features.
                        b->layerMaterial.type = global.main_material;
                        b->layerMaterial.index = global.sub_material;
                        b->material.type = global.main_material;
                        b->material.index = global.sub_material;
                        b->hasVein = 0;
                        //}
                    }
                }

                //read local features
                idx = trueBlock->local_feature;
                if( idx != -1 && local.type != -1 && local.main_material != -1 )
                {
                    if(trueBlock->designation[lx][ly].bits.feature_local)
                    {
                        //if(vectr[idx]->main_material == INORGANIC) // stone
                        //{
                        //We can probably get away with this.
                        b->veinMaterial.type = local.main_material;
                        b->veinMaterial.index = local.sub_material;
                        b->material.type = local.main_material;
                        b->material.index = local.sub_material;
                        b->hasVein = 1;
                        //}
                    }
                }

				if(b->tileMaterial == tiletype_material::LAVA_STONE)
                {
                    b->material.type = INORGANIC;
                    b->material.index = contentLoader->obsidian;
                }


				//string name = v_stonetypes[j].id;
				if (createdBlock)
				{
					segment.addBlock(b);
				}
			}else if (createdBlock){
				delete(b);
			}

		}
	}
		
	//add trees and other vegetation
	for(auto iter = trueBlock->plants.begin(); iter != trueBlock->plants.end(); iter++)
	{
        df::plant * wheat = *iter;
        assert(wheat != NULL);
        Block* b = segment.getBlock( wheat->pos.x, wheat->pos.y, wheat->pos.z);
        if(!b)
        {
            continue;
        }
        if( b->tileShape == tiletype_shape::TREE ||
            b->tileShape == tiletype_shape::SAPLING ||
            b->tileShape == tiletype_shape::SHRUB)
        {
            b->tree.type = wheat->flags.whole;
            b->tree.index = wheat->material;
        }
    }

	//add items
	for(auto iter = trueBlock->items.begin(); iter != trueBlock->items.end(); iter++)
	{
		int32_t item_index = *iter;
		df::item * found_item = df::item::find(item_index);
		if(!found_item) continue;
        Block* b = segment.getBlock( found_item->pos.x, found_item->pos.y, found_item->pos.z);
		if(!b) continue;
		b->Item.item.type = found_item->getType(); //itemtype
		b->Item.item.index = found_item->getSubtype(); //item subtype

		b->Item.matt.type = found_item->getActualMaterial();
		b->Item.matt.index = found_item->getActualMaterialIndex();

		if(1)//found_item->isDyed())
		{
			auto Constructed_Item = virtual_cast<df::item_constructed>(found_item);
			if(Constructed_Item)
			{
				for(int idex = 0; idex < Constructed_Item->improvements.size(); idex++)
				{
					if(!Constructed_Item->improvements[idex])
						continue;
					if(Constructed_Item->improvements[idex]->getType() != improvement_type::THREAD)
						continue;
					auto Improvement_Thread = virtual_cast<df::itemimprovement_threadst>(Constructed_Item->improvements[idex]);
					if(!Improvement_Thread)
						continue;
					if (Improvement_Thread->dye.mat_type < 0) break;
					b->Item.dyematt.type = Improvement_Thread->dye.mat_type;
					b->Item.dyematt.index = Improvement_Thread->dye.mat_index;
				}
			}
			else if (found_item->getType() == item_type::THREAD)
			{
				auto Thread_Item = virtual_cast<df::item_threadst>(found_item);
				if(!Thread_Item) break;
				if (Thread_Item->dye_mat_type < 0) break;
				b->Item.dyematt.type = Thread_Item->dye_mat_type;
				b->Item.dyematt.index = Thread_Item->dye_mat_index;
			}
		}
	}

	//add effects
	for(auto iter = trueBlock->flows.begin(); iter != trueBlock->flows.end(); iter++)
	{
        df::flow_info * eff = *iter;
        assert(eff != NULL);
        Block* b = segment.getBlock( eff->x, eff->y, eff->z);
        if(!b)
        {
			if(segment.CoordinateInsideSegment(eff->x, eff->y, eff->z))
			{
				b = new Block(&segment);
				b->x=eff->x;
				b->y=eff->y;
				b->z=eff->z;
				segment.addBlock(b);
			}
			else
				continue;
		}
		switch(eff->type)
		{
		case flow_type::Steam:
			{
				b->Eff_Steam.density += eff->density;
				b->Eff_Steam.matt.index = eff->mat_index;
				b->Eff_Steam.matt.type = eff->mat_type;
				break;
			}
		case flow_type::Mist:
			{
				b->Eff_Mist.density += eff->density;
				b->Eff_Mist.matt.index = eff->mat_index;
				b->Eff_Mist.matt.type = eff->mat_type;
				break;
			}
		case flow_type::MaterialDust:
			{
				b->Eff_MaterialDust.density += eff->density;
				b->Eff_MaterialDust.matt.index = eff->mat_index;
				b->Eff_MaterialDust.matt.type = eff->mat_type;
				break;
			}
		case flow_type::MagmaMist:
			{
				b->Eff_MagmaMist.density += eff->density;
				b->Eff_MagmaMist.matt.index = eff->mat_index;
				b->Eff_MagmaMist.matt.type = eff->mat_type;
				break;
			}
		case flow_type::Smoke:
			{
				b->Eff_Smoke.density += eff->density;
				b->Eff_Smoke.matt.index = eff->mat_index;
				b->Eff_Smoke.matt.type = eff->mat_type;
				break;
			}
		case flow_type::Dragonfire:
			{
				b->Eff_Dragonfire.density += eff->density;
				b->Eff_Dragonfire.matt.index = eff->mat_index;
				b->Eff_Dragonfire.matt.type = eff->mat_type;
				break;
			}
		case flow_type::Fire:
			{
				b->Eff_Fire.density += eff->density;
				b->Eff_Fire.matt.index = eff->mat_index;
				b->Eff_Fire.matt.type = eff->mat_type;
				break;
			}
		case flow_type::Web:
			{
				b->Eff_Web.density += eff->density;
				b->Eff_Web.matt.index = eff->mat_index;
				b->Eff_Web.matt.type = eff->mat_type;
				break;
			}
		case flow_type::MaterialGas:
			{
				b->Eff_MaterialGas.density += eff->density;
				b->Eff_MaterialGas.matt.index = eff->mat_index;
				b->Eff_MaterialGas.matt.type = eff->mat_type;
				break;
			}
		case flow_type::MaterialVapor:
			{
				b->Eff_MaterialVapor.density += eff->density;
				b->Eff_MaterialVapor.matt.index = eff->mat_index;
				b->Eff_MaterialVapor.matt.type = eff->mat_type;
				break;
			}
		case flow_type::OceanWave:
			{
				b->Eff_OceanWave.density += eff->density;
				b->Eff_OceanWave.matt.index = eff->mat_index;
				b->Eff_OceanWave.matt.type = eff->mat_type;
				break;
			}
		case flow_type::SeaFoam:
			{
				b->Eff_SeaFoam.density += eff->density;
				b->Eff_SeaFoam.matt.index = eff->mat_index;
				b->Eff_SeaFoam.matt.type = eff->mat_type;
				break;
			}
		}
	}
}


bool checkFloorBorderRequirement(WorldSegment* segment, int x, int y, int z, dirRelative offset)
{
	Block* bHigh = segment->getBlockRelativeTo(x, y, z, offset);
	if (bHigh && (bHigh->tileShapeBasic==tiletype_shape_basic::Floor || bHigh->tileShapeBasic==tiletype_shape_basic::Ramp || bHigh->tileShapeBasic==tiletype_shape_basic::Wall))
	{
		return false;
	}
	Block* bLow = segment->getBlockRelativeTo(x, y, z-1, offset);
	if (bLow == NULL || bLow->tileShapeBasic!=tiletype_shape_basic::Ramp)
	{
		return true;
	}
	return false;
}


WorldSegment* ReadMapSegment(int x, int y, int z, int sizex, int sizey, int sizez){
	uint32_t index;
	clock_t start_time = clock();
	DFHack::Core & DF = Core::getInstance();

	DFHack::World *Wold = 0;
	if(!config.skipWorld)
	{
        Wold = DF.getWorld();
	}

	//read date
	if(!config.skipWorld)
	{
		contentLoader->currentYear = Wold->ReadCurrentYear();
		contentLoader->currentTick = Wold->ReadCurrentTick();
		contentLoader->currentMonth = (contentLoader->currentTick+9)/33600;
		contentLoader->currentDay = ((contentLoader->currentTick+9)%33600)/1200;
		contentLoader->currentHour = ((contentLoader->currentTick+9)-(((contentLoader->currentMonth*28)+contentLoader->currentDay)*1200))/50;
		contentLoader->currentTickRel = (contentLoader->currentTick+9)-(((((contentLoader->currentMonth*28)+contentLoader->currentDay)*24)+contentLoader->currentHour)*50);
		Wold->ReadGameMode(contentLoader->gameMode);
	}

	if(!config.skipMaps)
	{
		if(!Maps::IsValid())
		{
			//WriteErr("Can't init map.");
			//DisconnectFromDF();
			//return new blank segment
			return new WorldSegment(x,y,z + 1,sizex,sizey,sizez + 1);
		}
	}
	else
	{
		//return new blank segment
		return new WorldSegment(x,y,z + 1,sizex,sizey,sizez + 1);
	}

	//if (timeToReloadConfig)
	//{
	//	contentLoader->Load(DF);
	//	timeToReloadConfig = false;
	//}



	//Read Number of cells
	int cellDimX, cellDimY, cellDimZ;
	Maps::getSize((unsigned int &)cellDimX, (unsigned int &)cellDimY, (unsigned int &)cellDimZ);
	//Store these
	cellDimX = cellDimX * 16;
	cellDimY = cellDimY * 16;
	cellDimZ = cellDimZ;
	config.cellDimX = cellDimX;
	config.cellDimY = cellDimY;
	config.cellDimZ = cellDimZ;
	//bound view to world
	if(x > cellDimX * CELLEDGESIZE -sizex/2) DisplayedSegmentX = x = cellDimX * CELLEDGESIZE -sizex/2;
	if(y > cellDimY * CELLEDGESIZE -sizey/2) DisplayedSegmentY = y = cellDimY * CELLEDGESIZE -sizey/2;
	if(x < -sizex/2) DisplayedSegmentX = x = -sizex/2;
	if(y < -sizey/2) DisplayedSegmentY = y = -sizey/2;

	//setup new world segment
	WorldSegment* segment = new WorldSegment(x,y,z,sizex,sizey,sizez);
	segment->regionSize.x = cellDimX * CELLEDGESIZE;
	segment->regionSize.y = cellDimY * CELLEDGESIZE;
	segment->regionSize.z = cellDimZ;
	segment->rotation = DisplayedRotation;

	//read world wide buildings
    vector<Buildings::t_building> allBuildings;
	if(!config.skipBuildings)
		ReadBuildings(DF, &allBuildings);

	/*if(GroundMaterialNamesTranslatedFromGame == false)
	TranslateGroundMaterialNames();*/

	// get region geology
	vector< vector <int16_t> > layers;
	vector<df::coord2d> geoidx;
	if(!Maps::ReadGeology( &layers, &geoidx ))
	{
		LogError("Can't get region geology.\n");
	}

	//read cursor
	Gui::getCursorCoords(config.dfCursorX, config.dfCursorY, config.dfCursorZ);

	// read constructions
	vector<df::construction> allConstructions;
	uint32_t numconstructions = 0;

	if(!config.skipConstructions)
	{
        numconstructions = Constructions::getCount();
        if (numconstructions)
        {
            df::construction tempcon;
            index = 0;
            while(index < numconstructions)
            {
                tempcon = *Constructions::getConstruction(index);
                if(segment->CoordinateInsideSegment(tempcon.pos.x, tempcon.pos.y, tempcon.pos.z))
                    allConstructions.push_back(tempcon);
                index++;
            }
        }
	}

	//merge buildings with segment
	if(!config.skipBuildings)
		MergeBuildingsToSegment(&allBuildings, segment);

	//figure out what cells to read
	int32_t firstTileToReadX = x;
	if( firstTileToReadX < 0 ) firstTileToReadX = 0;

	while(firstTileToReadX < x + sizex){
		int cellx = firstTileToReadX / CELLEDGESIZE;
		int32_t lastTileInCellX = (cellx+1) * CELLEDGESIZE - 1;
		int32_t lastTileToReadX = min<int32_t>(lastTileInCellX, x+sizex-1);

		int32_t firstTileToReadY = y;
		if( firstTileToReadY < 0 ) firstTileToReadY = 0;

		while(firstTileToReadY < y + sizey){
			int celly = firstTileToReadY / CELLEDGESIZE;
			int32_t lastTileInCellY = (celly+1) * CELLEDGESIZE - 1;
			int32_t lastTileToReadY = min<uint32_t>(lastTileInCellY, y+sizey-1);

			for(int lz=z-sizez; lz <= z; lz++){
				//load the blcoks from this cell to the map segment
				ReadCellToSegment(DF, *segment, cellx, celly, lz, 
					firstTileToReadX, firstTileToReadY, lastTileToReadX, lastTileToReadY,
					0, &allBuildings, &allConstructions, &layers );

			}
			firstTileToReadY = lastTileToReadY + 1;
		}
		firstTileToReadX = lastTileToReadX + 1;
	}

	//translate constructions
	changeConstructionMaterials(segment, &allConstructions);

    uint32_t numengravings = Engravings::getCount();
    df::engraving * engraved;
    index = 0;
    Block * b = 0;
    while(index < numengravings)
    {
        engraved = Engravings::getEngraving(index);
        df::coord pos = engraved->pos;
        if(segment->CoordinateInsideSegment(pos.x, pos.y, pos.z))
        {
            b = segment->getBlock(pos.x, pos.y, pos.z);
            b->engraving_character = engraved->tile;
            b->engraving_flags = engraved->flags;
            b->engraving_quality = engraved->quality;
        }
        index++;
    }

	//Read Creatures
	if(!config.skipCreatures)
		ReadCreaturesToSegment( DF, segment );

	segment->loaded = 1;
	segment->read_time = clock() - start_time;

	segment->processed = 0;

	return segment;
}

void beautify_Segment(WorldSegment * segment)
{
	if(!segment)
		return;
	clock_t start_time = clock();
	//do misc beautification
	uint32_t numblocks = segment->getNumBlocks();

	for(uint32_t i=0; i < numblocks; i++){
		Block* b = segment->getBlock(i);

		if(config.occlusion)
			occlude_block(b);

		if(!b->visible)
			continue;

		//Grass
		if(b->grasslevel > 0 && (
			(b->tileMaterial == tiletype_material::GRASS_LIGHT) || 
			(b->tileMaterial == tiletype_material::GRASS_DARK) ||
			(b->tileMaterial == tiletype_material::GRASS_DEAD) ||
			(b->tileMaterial == tiletype_material::GRASS_DRY)))
		{
			c_block_tree * vegetationsprite = 0;
			vegetationsprite = getVegetationTree(contentLoader->grassConfigs,b->grassmat,true,true);
			if(vegetationsprite)
				vegetationsprite->insert_sprites(segment, b->x, b->y, b->z, b);
		}

		//setup building sprites
		if( b->building.info.type != BUILDINGTYPE_NA && b->building.info.type != BUILDINGTYPE_BLACKBOX && b->building.info.type != BUILDINGTYPE_TREE)
			loadBuildingSprites( b);

		//populate trees
		if(b->tree.index)
		{
			c_block_tree * Tree = GetTreeVegetation(b->tileShape, b->tileSpecial, b->tree.index );
			Tree->insert_sprites(segment, b->x, b->y, b->z, b);
		}


		//setup deep water
		if( b->water.index == 7 && b->water.type == 0)
		{
			int topdepth = blockWaterDepth(b->x, b->y, b->z, segment, eAbove);
			if(topdepth)
				b->water.index = 8;
		}


		//setup ramps
		if(b->tileShapeBasic==tiletype_shape_basic::Ramp) 
			b->ramp.index = CalculateRampType(b->x, b->y, b->z, segment);
		//add edges to blocks and floors  

		Block * dir1 = segment->getBlockRelativeTo(b->x, b->y, b->z, eUpLeft);
		Block * dir2 = segment->getBlockRelativeTo(b->x, b->y, b->z, eUp);
		Block * dir3 = segment->getBlockRelativeTo(b->x, b->y, b->z, eUpRight);
		Block * dir4 = segment->getBlockRelativeTo(b->x, b->y, b->z, eRight);
		Block * dir5 = segment->getBlockRelativeTo(b->x, b->y, b->z, eDownRight);
		Block * dir6 = segment->getBlockRelativeTo(b->x, b->y, b->z, eDown);
		Block * dir7 = segment->getBlockRelativeTo(b->x, b->y, b->z, eDownLeft);
		Block * dir8 = segment->getBlockRelativeTo(b->x, b->y, b->z, eLeft);

		b->obscuringBuilding=0;
		b->obscuringCreature=0;

		if(dir1) if(dir1->creaturePresent) b->obscuringCreature = 1;
		if(dir2) if(dir2->creaturePresent) b->obscuringCreature = 1;
		if(dir8) if(dir8->creaturePresent) b->obscuringCreature = 1;

        if(dir1)
            if(dir1->building.info.type != BUILDINGTYPE_NA
                && dir1->building.info.type != BUILDINGTYPE_BLACKBOX
                && dir1->building.info.type != df::enums::building_type::Civzone
                && dir1->building.info.type != df::enums::building_type::Stockpile
            )
                b->obscuringBuilding = 1;
        if(dir2)
            if(dir2->building.info.type != BUILDINGTYPE_NA
                && dir2->building.info.type != BUILDINGTYPE_BLACKBOX
                && dir2->building.info.type != df::enums::building_type::Civzone
                && dir2->building.info.type != df::enums::building_type::Stockpile
            )
                b->obscuringBuilding = 1;
        if(dir8)
            if(dir8->building.info.type != BUILDINGTYPE_NA
                && dir8->building.info.type != BUILDINGTYPE_BLACKBOX
                && dir8->building.info.type != df::enums::building_type::Civzone
                && dir8->building.info.type != df::enums::building_type::Stockpile
            ) b->obscuringBuilding = 1;

		if( b->tileShapeBasic==tiletype_shape_basic::Floor )
		{
			b->depthBorderWest = checkFloorBorderRequirement(segment, b->x, b->y, b->z, eLeft);
			b->depthBorderNorth = checkFloorBorderRequirement(segment, b->x, b->y, b->z, eUp);

			Block* belowBlock = segment->getBlockRelativeTo(b->x, b->y, b->z, eBelow);
			if(!belowBlock || (belowBlock->tileShapeBasic!=tiletype_shape_basic::Wall && belowBlock->tileShapeBasic!=tiletype_shape_basic::Wall)) 
				b->depthBorderDown = true;
		}
		else if( b->tileShapeBasic==tiletype_shape_basic::Wall && wallShouldNotHaveBorders( b->tileType ) == false )
		{
			Block* leftBlock = segment->getBlockRelativeTo(b->x, b->y, b->z, eLeft);
			Block* upBlock = segment->getBlockRelativeTo(b->x, b->y, b->z, eUp);
			if(!leftBlock || (leftBlock->tileShapeBasic!=tiletype_shape_basic::Wall && leftBlock->tileShapeBasic!=tiletype_shape_basic::Ramp)) 
				b->depthBorderWest = true;
			if(!upBlock || (upBlock->tileShapeBasic!=tiletype_shape_basic::Wall && upBlock->tileShapeBasic!=tiletype_shape_basic::Ramp))
				b->depthBorderNorth = true;
			Block* belowBlock = segment->getBlockRelativeTo(b->x, b->y, b->z, eBelow);
			if(!belowBlock || (belowBlock->tileShapeBasic!=tiletype_shape_basic::Wall && belowBlock->tileShapeBasic!=tiletype_shape_basic::Ramp)) 
				b->depthBorderDown = true;
		}
		b->wallborders = 0;
		if(dir1) if(dir1->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 1;
		if(dir2) if(dir2->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 2;
		if(dir3) if(dir3->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 4;
		if(dir4) if(dir4->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 8;
		if(dir5) if(dir5->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 16;
		if(dir6) if(dir6->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 32;
		if(dir7) if(dir7->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 64;
		if(dir8) if(dir8->tileShapeBasic==tiletype_shape_basic::Wall) b->wallborders |= 128;

		b->rampborders = 0;
		if(dir1) if(dir1->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 1;
		if(dir2) if(dir2->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 2;
		if(dir3) if(dir3->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 4;
		if(dir4) if(dir4->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 8;
		if(dir5) if(dir5->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 16;
		if(dir6) if(dir6->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 32;
		if(dir7) if(dir7->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 64;
		if(dir8) if(dir8->tileShapeBasic==tiletype_shape_basic::Ramp) b->wallborders |= 128;

		b->upstairborders = 0;
		b->downstairborders = 0;
		if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 1;
		if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 2;
		if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 4;
		if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 8;
		if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 16;
		if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 32;
		if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 64;
		if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_UP) b->upstairborders |= 128;

		if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 1;
		if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 2;
		if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 4;
		if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 8;
		if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 16;
		if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 32;
		if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 64;
		if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_UPDOWN) b->upstairborders |= 128;

		if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 1;
		if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 2;
		if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 4;
		if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 8;
		if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 16;
		if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 32;
		if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 64;
		if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_UPDOWN) b->downstairborders |= 128;

		if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 1;
		if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 2;
		if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 4;
		if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 8;
		if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 16;
		if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 32;
		if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 64;
		if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_DOWN) b->downstairborders |= 128;

		b->floorborders = 0;
		if(dir1) if(dir1->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 1;
		if(dir2) if(dir2->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 2;
		if(dir3) if(dir3->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 4;
		if(dir4) if(dir4->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 8;
		if(dir5) if(dir5->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 16;
		if(dir6) if(dir6->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 32;
		if(dir7) if(dir7->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 64;
		if(dir8) if(dir8->tileShapeBasic==tiletype_shape_basic::Floor) b->floorborders |= 128;

		b->lightborders = 0;
		if(dir1) if(!dir1->designation.bits.outside) b->lightborders |= 1;
        if(dir2) if(!dir2->designation.bits.outside) b->lightborders |= 2;
        if(dir3) if(!dir3->designation.bits.outside) b->lightborders |= 4;
        if(dir4) if(!dir4->designation.bits.outside) b->lightborders |= 8;
        if(dir5) if(!dir5->designation.bits.outside) b->lightborders |= 16;
        if(dir6) if(!dir6->designation.bits.outside) b->lightborders |= 32;
        if(dir7) if(!dir7->designation.bits.outside) b->lightborders |= 64;
        if(dir8) if(!dir8->designation.bits.outside) b->lightborders |= 128;
		b->lightborders = ~b->lightborders;

		b->openborders = ~(b->floorborders|b->rampborders|b->wallborders|b->downstairborders|b->upstairborders);
	}
	segment->processed = 1;
	segment->beautify_time = clock() - start_time;
}

void FollowCurrentDFWindow()
{
    int32_t newviewx;
    int32_t newviewy;
    int32_t viewsizex;
    int32_t viewsizey;
    int32_t newviewz;
    int32_t mapx, mapy, mapz;
    // we take the rectangle you'd get if you scrolled the DF view closely around
    // map edges with a pen pierced through the center,
    // compute the scaling factor between this rectangle and the map bounds and then scale
    // the coords with this scaling factor
    /**
    +---+
    |W+-++----------+
    +-+-+---------+ |
      | |         | |
      | | inner   | |
      | |   rect. | |
      | |         | |
      | |         | |--- map boundary
      | +---------+ |
      +-------------+  W - corrected view
    */
    Maps::getSize((uint32_t &)mapx, (uint32_t &)mapy, (uint32_t &)mapz);
    mapx *= 16;
    mapy *= 16;

    Gui::getWindowSize(viewsizex,viewsizey);
    float scalex = float (mapx) / float (mapx - viewsizex);
    float scaley = float (mapy) / float (mapy - viewsizey);

    Gui::getViewCoords(newviewx,newviewy,newviewz);
    newviewx = newviewx + (viewsizex / 2) - mapx / 2;
    newviewy = newviewy + (viewsizey / 2) - mapy / 2;

    parms.x = float (newviewx) * scalex - (config.segmentSize.x / 2) + config.viewXoffset + mapx / 2;
    parms.y = float (newviewy) * scaley - (config.segmentSize.y / 2) + config.viewYoffset + mapy / 2;
    parms.z = newviewz + config.viewZoffset + 1;
}

void FollowCurrentDFCenter()
{
    int32_t newviewx;
    int32_t newviewy;
    int32_t viewsizex;
    int32_t viewsizey;
    int32_t newviewz;
    Gui::getWindowSize(viewsizex,viewsizey);
    Gui::getViewCoords(newviewx,newviewy,newviewz);
    int screenx, screeny, screenz;
    ScreenToPoint(config.screenWidth/2, config.screenHeight/2, screenx, screeny, screenz);
    parms.x = newviewx + (viewsizex/2) - screenx + config.viewXoffset;
    parms.y = newviewy + (viewsizey/2) - screeny + config.viewYoffset;
    parms.z = newviewz + config.viewZoffset + 1;
}

void read_segment( void *arg)
{
    if(!Maps::IsValid())
        return;
    static bool firstLoad = 1;
    config.threadstarted = 1;
    WorldSegment * segment = 0;
    // Suspended block
    {
        CoreSuspender suspend;
        if (firstLoad || config.follow_DFscreen)
        {
            firstLoad = 0;
            if (config.track_center)
            {
                FollowCurrentDFCenter();
            }
            else
            {
                FollowCurrentDFWindow();
            }
        }
        segment = ReadMapSegment(parms.x, parms.y, parms.z,parms.sizex, parms.sizey, parms.sizez);
        config.threadstarted = 0;
    }
    beautify_Segment(segment);
    map_segment->lock();
    WorldSegment* old_segment = map_segment->swap(segment);
    map_segment->unlock();
    if(old_segment)
    {
        old_segment->Dispose();
        delete old_segment;
    }
}

static void * threadedSegment(ALLEGRO_THREAD *read_thread, void *arg)
{
	while(!al_get_thread_should_stop(read_thread))
	{
		al_lock_mutex(config.readMutex);
		read_segment(arg);
		al_unlock_mutex(config.readMutex);
		al_rest(config.automatic_reload_time/1000.0);
	}
	return 0;
}

void reloadDisplayedSegment(){
	//create handle to dfHack API
	static bool firstLoad = 1;
	TMR1_START;

#ifndef RELEASE
	firstLoad=false;
#endif

	if (timeToReloadConfig)
	{
		parms.thread_connect = 0;
		contentLoader->Load();
		timeToReloadConfig = false;
	}

	if (firstLoad || config.follow_DFscreen)
	{
		DisplayedSegmentX = parms.x;
		DisplayedSegmentY = parms.y;
		DisplayedSegmentZ = parms.z;
		}

	int segmentHeight = config.single_layer_view ? 2 : config.segmentSize.z;
	//load segment
	if(config.threading_enable)
	{
		if(!config.threadmade)
		{
			config.readThread = al_create_thread(threadedSegment, NULL);
			config.threadmade = 1;
		}
	}

	parms.x = DisplayedSegmentX;
	parms.y = DisplayedSegmentY;
	parms.z = DisplayedSegmentZ;
	parms.sizex = config.segmentSize.x;
	parms.sizey = config.segmentSize.y;
	parms.sizez = segmentHeight;

	if(config.threading_enable)
		al_start_thread(config.readThread);
	else
		read_segment(NULL);

	firstLoad = 0;
	TMR1_STOP;
}
