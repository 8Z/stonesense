#include "common.h"
#include "GUI.h"
#include "MapLoading.h"
#include "WorldSegment.h"
#include "SpriteMaps.h"
#include "Constructions.h"
#include "GameBuildings.h"
#include "Creatures.h"
#include "ContentLoader.h"
#include "OcclusionTest.h"
#include <df/flow_info.h>
#include <df/plant.h>
#include <df/flow_info.h>
#include "df/item_constructed.h"
#include "df/itemimprovement.h"
#include "df/itemimprovement_threadst.h"
#include "df/item_threadst.h"

bool connected = 0;
bool threadrunnng = 0;
segParams parms;

//big look up table
uint8_t rampblut[] =
    // generated by blutmaker.py
{
    1 ,  2 ,  8 ,  2 ,  4 , 12 ,  4 , 12 ,  9 ,  2 , 21 ,  2 ,  4 , 12 ,  4 , 12 ,
    5 , 16 ,  5 , 16 , 13 , 13 , 13 , 12 ,  5 , 16 ,  5 , 16 , 13 , 13 , 13 , 16 ,
    7 ,  2 , 14 ,  2 ,  4 , 12 ,  4 , 12 , 20 , 26 , 25 , 26 ,  4 , 12 ,  4 , 12 ,
    5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,
    3 , 10 ,  3 , 10 , 17 , 12 , 17 , 12 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 10 , 11 , 16 , 11 , 26 , 17 , 12 , 11 , 16 , 11 , 16 , 13 , 13 , 17 , 16 ,
    3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 11 , 11 , 16 , 11 , 11 , 17 , 14 , 11 , 16 , 11 , 16 , 17 , 17 , 17 , 13 ,
    6 ,  2 , 19 ,  2 ,  4 , 12 ,  4 , 12 , 15 ,  2 , 24 ,  2 ,  4 , 12 ,  4 , 12 ,
    5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
    18 ,  2 , 22 ,  2 , 26 , 12 , 26 , 12 , 23 , 26 , 26 , 26 , 26 , 12 , 26 , 12 ,
    5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
    3 , 10 ,  3 , 10 , 17 , 10 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 10 , 11 , 16 , 17 , 10 , 17 , 17 , 11 , 16 , 11 , 16 , 17 , 15 , 17 , 12 ,
    3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 16 , 11 , 16 , 17 , 16 , 17 , 10 , 11 , 16 , 11 , 16 , 17 , 11 , 17 , 26
};

inline bool isTileHighRampEnd(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
    Tile* tile = segment->getTileRelativeTo( x, y, z, dir);
    if(!tile) {
        return false;
    }
    if(tile->tileShapeBasic()!=tiletype_shape_basic::Wall) {
        return false;
    }
    return IDisWall( tile->tileType );
}

inline int tileWaterDepth(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
    Tile* tile = segment->getTileRelativeTo( x, y, z, dir);
    if(!tile) {
        return false;
    }
    if(tile->designation.bits.flow_size == 0 || tile->designation.bits.liquid_type == 1) {
        return false;
    }
    return tile->designation.bits.flow_size;
}

inline bool isTileHighRampTop(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
    Tile* tile = segment->getTileRelativeTo( x, y, z, dir);
    if(!tile) {
        return false;
    }
    if(tile->tileShapeBasic()!=tiletype_shape_basic::Floor 
        && tile->tileShapeBasic()!=tiletype_shape_basic::Ramp 
        && tile->tileShapeBasic()!=tiletype_shape_basic::Stair) {
            return false;
    }
    if(tile->tileShapeBasic()!=tiletype_shape_basic::Wall) {
        return true;
    }
    return !IDisWall( tile->tileType );
}

inline bool isTileOnTopOfSegment(WorldSegment* segment, Tile* b)
{
    return b->z == segment->pos.z + segment->size.z - 2;
}

uint8_t CalculateRampType(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment)
{
    int32_t ramplookup = 0;
    if (isTileHighRampEnd(x, y, z, segment, eUp) && isTileHighRampTop(x, y, z+1, segment, eUp)) {
        ramplookup ^= 1;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpRight) && isTileHighRampTop(x, y, z+1, segment, eUpRight)) {
        ramplookup ^= 2;
    }
    if (isTileHighRampEnd(x, y, z, segment, eRight) && isTileHighRampTop(x, y, z+1, segment, eRight)) {
        ramplookup ^= 4;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownRight) && isTileHighRampTop(x, y, z+1, segment, eDownRight)) {
        ramplookup ^= 8;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDown) && isTileHighRampTop(x, y, z+1, segment, eDown)) {
        ramplookup ^= 16;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownLeft) && isTileHighRampTop(x, y, z+1, segment, eDownLeft)) {
        ramplookup ^= 32;
    }
    if (isTileHighRampEnd(x, y, z, segment, eLeft) && isTileHighRampTop(x, y, z+1, segment, eLeft)) {
        ramplookup ^= 64;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpLeft) && isTileHighRampTop(x, y, z+1, segment, eUpLeft)) {
        ramplookup ^= 128;
    }

    // creation should ensure in range
    if (ramplookup > 0) {
        return rampblut[ramplookup];
    }

    if (isTileHighRampEnd(x, y, z, segment, eUp)) {
        ramplookup ^= 1;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpRight)) {
        ramplookup ^= 2;
    }
    if (isTileHighRampEnd(x, y, z, segment, eRight)) {
        ramplookup ^= 4;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownRight)) {
        ramplookup ^= 8;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDown)) {
        ramplookup ^= 16;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownLeft)) {
        ramplookup ^= 32;
    }
    if (isTileHighRampEnd(x, y, z, segment, eLeft)) {
        ramplookup ^= 64;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpLeft)) {
        ramplookup ^= 128;
    }

    // creation should ensure in range
    return rampblut[ramplookup];
}

bool isTileOnVisibleEdgeOfSegment(WorldSegment* segment, Tile* b)
{
    if(b->z == segment->pos.z + segment->size.z - 2) {
        return true;
    }

    if (ssState.DisplayedRotation == 0 &&
        (
        b->x == segment->pos.x + segment->size.x - 2
        || b->y == segment->pos.y + segment->size.y - 2
        || b->x == segment->regionSize.x - 1
        || b->y == segment->regionSize.y - 1
        )) {
            return true;
    } else if (ssState.DisplayedRotation == 1 &&
        (
        b->x == segment->pos.x + segment->size.x - 2
        || b->y == segment->pos.y + 1
        || b->x == segment->regionSize.x - 1
        || b->y == 0
        )) {
            return true;
    } else if (ssState.DisplayedRotation == 2 &&
        (
        b->x == segment->pos.x + 1
        || b->y == segment->pos.y + 1
        || b->x == 0
        || b->y == 0
        )) {
            return true;
    } else if (ssState.DisplayedRotation == 3 &&
        (
        b->x == segment->pos.x + 1
        || b->y == segment->pos.y + segment->size.y - 2
        || b->x == 0
        || b->y == segment->regionSize.y - 1
        )) {
            return true;
    }

    return false;
}

bool areNeighborsVisible(WorldSegment* segment, Tile* b)
{
    Tile* temp;

    temp = segment->getTile(b->x, b->y, b->z+1);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }

    temp = segment->getTile(b->x+1, b->y, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    temp = segment->getTile(b->x-1, b->y, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    temp = segment->getTile(b->x, b->y+1, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    temp = segment->getTile(b->x, b->y-1, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    return false;
}

/**
* returns true iff the tile is enclosed by other solid tiles, and is itself solid
*/
bool enclosed(WorldSegment* segment, Tile* b)
{
    if(!IDisWall(b->tileType)) {
        return false;
    }

    Tile* temp;
    temp = segment->getTile(b->x, b->y, b->z+1);
    if(!temp || !IDhasOpaqueFloor(temp->tileType)) {
        return false;
    }

    temp = segment->getTile(b->x+1, b->y, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }
    temp = segment->getTile(b->x-1, b->y, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }
    temp = segment->getTile(b->x, b->y+1, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }
    temp = segment->getTile(b->x, b->y-1, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }

    return true;
}

void ReadBlockToSegment(DFHack::Core& DF, WorldSegment& segment, int BlockX, int BlockY, int BlockZ,
    uint32_t BoundrySX, uint32_t BoundrySY,
    uint32_t BoundryEX, uint32_t BoundryEY
    //uint16_t Flags/*not in use*/,
    //vector<Buildings::t_building>* allBuildings,
    //vector<df::construction>* allConstructions,
    )
{
    if(ssConfig.skipMaps) {
        return;
    }
    //boundry check
    int blockDimX, blockDimY, blockDimZ;
    Maps::getSize((unsigned int &)blockDimX, (unsigned int &)blockDimY, (unsigned int &)blockDimZ);
    if( BlockX < 0 || BlockX >= blockDimX ||
        BlockY < 0 || BlockY >= blockDimY ||
        BlockZ < 0 || BlockZ >= blockDimZ ) {
            return;
    }

    //make boundries local
    BoundrySX -= BlockX * BLOCKEDGESIZE;
    BoundryEX -= BlockX * BLOCKEDGESIZE;
    BoundrySY -= BlockY * BLOCKEDGESIZE;
    BoundryEY -= BlockY * BLOCKEDGESIZE;

    //read block data
    df::map_block *trueBlock;
    trueBlock = Maps::getBlock(BlockX, BlockY, BlockZ);
    if(!trueBlock) {
        return;
    }

    //parse block
    for(uint32_t ly = BoundrySY; ly <= BoundryEY; ly++) {
        for(uint32_t lx = BoundrySX; lx <= BoundryEX; lx++) {
            uint32_t gx = lx + (BlockX * BLOCKEDGESIZE);
            uint32_t gy = ly + (BlockY * BLOCKEDGESIZE);
            if( !segment.CoordinateInsideSegment( gx, gy, BlockZ) ) {
                continue;
            }

            bool shouldBeIncluded = true;

            //if(isOpenTerrain(trueBlock->tiletype[lx][ly]) && trueBlock->tiletype[lx][ly] != tiletype::RampTop) {
            //    if(ssConfig.show_hidden_tiles) {
            //        shouldBeIncluded = false;
            //    } else if(!(trueBlock->designation[lx][ly].bits.hidden)) {
            //        shouldBeIncluded = false;
            //    }
            //} else if(!ssConfig.show_hidden_tiles
            //    && trueBlock->designation[lx][ly].bits.hidden) {
            //        shouldBeIncluded = false;
            //}

            ////add back in any liquid tiles, in case they can be seen from above
            //if(trueBlock->designation[lx][ly].bits.flow_size) {
            //    shouldBeIncluded = true;
            //}

            if(!shouldBeIncluded){
                continue;
            }

            Tile * b = segment.ResetTile(gx, gy, BlockZ, tiletype::OpenSpace);

            b->occ = trueBlock->occupancy[lx][ly];
            b->occ.bits.unit = false;//this will be set manually when we read the creatures vector
            b->designation = trueBlock->designation[lx][ly];
            //read tiletype
            b->tileType = trueBlock->tiletype[lx][ly];
            b->fog_of_war = !b->designation.bits.pile;
        }
    }

    //add trees and other vegetation
    for(auto iter = trueBlock->plants.begin(); iter != trueBlock->plants.end(); iter++) {
        df::plant * wheat = *iter;
        assert(wheat != NULL);
        Tile* b = segment.getTile( wheat->pos.x, wheat->pos.y, wheat->pos.z);
        if(!b) {
            continue;
        }
        if( b->tileShape() == tiletype_shape::TREE ||
            b->tileShape() == tiletype_shape::SAPLING ||
            b->tileShape() == tiletype_shape::SHRUB) {
                b->tree.type = wheat->flags.whole;
                b->tree.index = wheat->material;
        }
    }

    //add items
    for(auto iter = trueBlock->items.begin(); iter != trueBlock->items.end(); iter++) {
        int32_t item_index = *iter;
        df::item * found_item = df::item::find(item_index);
        if(!found_item) {
            continue;
        }
        Tile* b = segment.getTile( found_item->pos.x, found_item->pos.y, found_item->pos.z);
        if(!b) {
            continue;
        }
        b->Item.item.type = found_item->getType(); //itemtype
        b->Item.item.index = found_item->getSubtype(); //item subtype

        b->Item.matt.type = found_item->getActualMaterial();
        b->Item.matt.index = found_item->getActualMaterialIndex();

        if(1) { //found_item->isDyed())
            auto Constructed_Item = virtual_cast<df::item_constructed>(found_item);
            if(Constructed_Item) {
                for(int idex = 0; idex < Constructed_Item->improvements.size(); idex++) {
                    if(!Constructed_Item->improvements[idex]) {
                        continue;
                    }
                    if(Constructed_Item->improvements[idex]->getType() != improvement_type::THREAD) {
                        continue;
                    }
                    auto Improvement_Thread = virtual_cast<df::itemimprovement_threadst>(Constructed_Item->improvements[idex]);
                    if(!Improvement_Thread) {
                        continue;
                    }
                    if (Improvement_Thread->dye.mat_type < 0) {
                        break;
                    }
                    b->Item.dyematt.type = Improvement_Thread->dye.mat_type;
                    b->Item.dyematt.index = Improvement_Thread->dye.mat_index;
                }
            } else if (found_item->getType() == item_type::THREAD) {
                auto Thread_Item = virtual_cast<df::item_threadst>(found_item);
                if(!Thread_Item) {
                    break;
                }
                if (Thread_Item->dye_mat_type < 0) {
                    break;
                }
                b->Item.dyematt.type = Thread_Item->dye_mat_type;
                b->Item.dyematt.index = Thread_Item->dye_mat_index;
            }
        }
    }


    //add effects
    for(auto iter = trueBlock->flows.begin(); iter != trueBlock->flows.end(); iter++) {
        df::flow_info * eff = *iter;
        if(eff == NULL || eff->density <= 0) {
            continue;
        }
        Tile* b = segment.getTile( eff->pos.x, eff->pos.y, eff->pos.z);
        if(segment.CoordinateInsideSegment(eff->pos.x, eff->pos.y, eff->pos.z)) {
            if(!b) {
                continue;
            }
            b->haseffect = true;
            switch(eff->type) {
            case flow_type::Steam: {
                b->Eff_Steam.density += eff->density;
                b->Eff_Steam.matt.index = eff->mat_index;
                b->Eff_Steam.matt.type = eff->mat_type;
                break;
                                   }
            case flow_type::Mist: {
                b->Eff_Mist.density += eff->density;
                b->Eff_Mist.matt.index = eff->mat_index;
                b->Eff_Mist.matt.type = eff->mat_type;
                break;
                                  }
            case flow_type::MaterialDust: {
                b->Eff_MaterialDust.density += eff->density;
                b->Eff_MaterialDust.matt.index = eff->mat_index;
                b->Eff_MaterialDust.matt.type = eff->mat_type;
                break;
                                          }
            case flow_type::MagmaMist: {
                b->Eff_MagmaMist.density += eff->density;
                b->Eff_MagmaMist.matt.index = eff->mat_index;
                b->Eff_MagmaMist.matt.type = eff->mat_type;
                break;
                                       }
            case flow_type::Smoke: {
                b->Eff_Smoke.density += eff->density;
                b->Eff_Smoke.matt.index = eff->mat_index;
                b->Eff_Smoke.matt.type = eff->mat_type;
                break;
                                   }
            case flow_type::Dragonfire: {
                b->Eff_Dragonfire.density += eff->density;
                b->Eff_Dragonfire.matt.index = eff->mat_index;
                b->Eff_Dragonfire.matt.type = eff->mat_type;
                break;
                                        }
            case flow_type::Fire: {
                b->Eff_Fire.density += eff->density;
                b->Eff_Fire.matt.index = eff->mat_index;
                b->Eff_Fire.matt.type = eff->mat_type;
                break;
                                  }
            case flow_type::Web: {
                b->Eff_Web.density += eff->density;
                b->Eff_Web.matt.index = eff->mat_index;
                b->Eff_Web.matt.type = eff->mat_type;
                break;
                                 }
            case flow_type::MaterialGas: {
                b->Eff_MaterialGas.density += eff->density;
                b->Eff_MaterialGas.matt.index = eff->mat_index;
                b->Eff_MaterialGas.matt.type = eff->mat_type;
                break;
                                         }
            case flow_type::MaterialVapor: {
                b->Eff_MaterialVapor.density += eff->density;
                b->Eff_MaterialVapor.matt.index = eff->mat_index;
                b->Eff_MaterialVapor.matt.type = eff->mat_type;
                break;
                                           }
            case flow_type::OceanWave: {
                b->Eff_OceanWave.density += eff->density;
                b->Eff_OceanWave.matt.index = eff->mat_index;
                b->Eff_OceanWave.matt.type = eff->mat_type;
                break;
                                       }
            case flow_type::SeaFoam: {
                b->Eff_SeaFoam.density += eff->density;
                b->Eff_SeaFoam.matt.index = eff->mat_index;
                b->Eff_SeaFoam.matt.type = eff->mat_type;
                break;
                                     }
            }
        } 
    }
}


bool checkFloorBorderRequirement(WorldSegment* segment, int x, int y, int z, dirRelative offset)
{
    Tile* bHigh = segment->getTileRelativeTo(x, y, z, offset);
    if (bHigh && 
        (bHigh->tileShapeBasic()==tiletype_shape_basic::Floor 
        || bHigh->tileShapeBasic()==tiletype_shape_basic::Ramp 
        || bHigh->tileShapeBasic()==tiletype_shape_basic::Wall)) {
            return false;
    }
    Tile* bLow = segment->getTileRelativeTo(x, y, z-1, offset);
    if (bLow == NULL || bLow->tileShapeBasic()!=tiletype_shape_basic::Ramp) {
        return true;
    }
    return false;
}


void readMapSegment(WorldSegment* segment, int x, int y, int z, int sizex, int sizey, int sizez)
{
    uint32_t index;
    DFHack::Core & DF = Core::getInstance();
    clock_t starttime = clock();

    //read date
    if(!ssConfig.skipWorld) {
        contentLoader->currentYear = World::ReadCurrentYear();
        contentLoader->currentTick = World::ReadCurrentTick();
        contentLoader->currentMonth = (contentLoader->currentTick+9)/33600;
        contentLoader->currentDay = ((contentLoader->currentTick+9)%33600)/1200;
        contentLoader->currentHour = ((contentLoader->currentTick+9)-(((contentLoader->currentMonth*28)+contentLoader->currentDay)*1200))/50;
        contentLoader->currentTickRel = (contentLoader->currentTick+9)-(((((contentLoader->currentMonth*28)+contentLoader->currentDay)*24)+contentLoader->currentHour)*50);
        World::ReadGameMode(contentLoader->gameMode);
    }

    if(ssConfig.skipMaps || !Maps::IsValid()) {
        segment->Reset(x,y,z + 1,sizex,sizey,sizez + 1,true);
        return;
    }

    //Read Number of blocks
    uint32_t blockDimX, blockDimY, blockDimZ;
    Maps::getSize(blockDimX, blockDimY, blockDimZ);
    //Read position of blocks
    uint32_t regionX, regionY, regionZ;
    Maps::getSize(regionX, regionY, regionZ);
    //Store these
    blockDimX *= BLOCKEDGESIZE;
    blockDimY *= BLOCKEDGESIZE;
    regionX *= BLOCKEDGESIZE;
    regionY *= BLOCKEDGESIZE;
    ssConfig.blockDimX = blockDimX;
    ssConfig.blockDimY = blockDimY;
    ssConfig.blockDimZ = blockDimZ;

    //setup new world segment
    segment->Reset(x,y,z,sizex,sizey,sizez,false);
    segment->regionSize.x = blockDimX;
    segment->regionSize.y = blockDimY;
    segment->regionSize.z = blockDimZ;
    segment->regionPos.x = regionX;
    segment->regionPos.y = regionY;
    segment->regionPos.z = regionZ;
    segment->rotation = ssState.DisplayedRotation;

    //read world wide buildings
    vector<Buildings::t_building> allBuildings;
    if(!ssConfig.skipBuildings) {
        ReadBuildings(DF, &allBuildings);
    }

    /*if(GroundMaterialNamesTranslatedFromGame == false)
    TranslateGroundMaterialNames();*/

    //read cursor
    Gui::getCursorCoords(ssConfig.dfCursorX, ssConfig.dfCursorY, ssConfig.dfCursorZ);

    // read constructions
    vector<df::construction> allConstructions;
    uint32_t numconstructions = 0;

    if(!ssConfig.skipConstructions) {
        numconstructions = Constructions::getCount();
        if (numconstructions) {
            df::construction tempcon;
            index = 0;
            while(index < numconstructions) {
                tempcon = *Constructions::getConstruction(index);
                if(segment->CoordinateInsideSegment(tempcon.pos.x, tempcon.pos.y, tempcon.pos.z)) {
                    allConstructions.push_back(tempcon);
                }
                index++;
            }
        }
    }

    //figure out what blocks to read
    int32_t firstTileToReadX = x;
    if( firstTileToReadX < 0 ) {
        firstTileToReadX = 0;
    }
    
    while(firstTileToReadX < x + sizex) {
        int blockx = firstTileToReadX / BLOCKEDGESIZE;
        int32_t lastTileInBlockX = (blockx+1) * BLOCKEDGESIZE - 1;
        int32_t lastTileToReadX = min<int32_t>(lastTileInBlockX, x+sizex-1);

        int32_t firstTileToReadY = y;
        if( firstTileToReadY < 0 ) {
            firstTileToReadY = 0;
        }

        while(firstTileToReadY < y + sizey) {
            int blocky = firstTileToReadY / BLOCKEDGESIZE;
            int32_t lastTileInBlockY = (blocky+1) * BLOCKEDGESIZE - 1;
            int32_t lastTileToReadY = min<uint32_t>(lastTileInBlockY, y+sizey-1);

            for(int lz=z-sizez; lz <= z; lz++) {
                //load the tiles from this block to the map segment
                ReadBlockToSegment(DF, *segment, blockx, blocky, lz,
                    firstTileToReadX, firstTileToReadY, 
                    lastTileToReadX, lastTileToReadY);

            }
            firstTileToReadY = lastTileToReadY + 1;
        }
        firstTileToReadX = lastTileToReadX + 1;
    }


    //merge buildings with segment
    if(!ssConfig.skipBuildings) {
        MergeBuildingsToSegment(&allBuildings, segment);
    }

    //translate constructions
    changeConstructionMaterials(segment, &allConstructions);

    uint32_t numengravings = Engravings::getCount();
    df::engraving * engraved;
    index = 0;
    Tile * b = 0;
    while(index < numengravings) {
        engraved = Engravings::getEngraving(index);
        df::coord pos = engraved->pos;
        if(segment->CoordinateInsideSegment(pos.x, pos.y, pos.z)) {
            b = segment->getTile(pos.x, pos.y, pos.z);
            if(!b) {
                continue;
            }
            b->engraving_character = engraved->tile;
            b->engraving_flags = engraved->flags;
            b->engraving_quality = engraved->quality;
        }
        index++;
    }

    //Read Creatures
    if(!ssConfig.skipCreatures) {
        ReadCreaturesToSegment( DF, segment );
    }

    segment->loaded = 1;
    segment->processed = 0;
    ssTimers.read_time = (clock() - starttime)*0.1 + ssTimers.read_time*0.9;
}

/**
* checks to see if the tile is a potentially viewable hidden tile
*  if so, put the black mask tile overtop
*  if not, makes tile not visible
*/
inline void maskTile(WorldSegment * segment, Tile* b)
{
    //include hidden tiles as shaded black, make remaining invisible
    if( b->designation.bits.hidden ) {
        if( isTileOnVisibleEdgeOfSegment(segment, b)
            || areNeighborsVisible(segment, b) ) {
                b->building.info.type = (building_type::building_type) BUILDINGTYPE_BLACKBOX;
        } else {
            b->visible = false;
        }
    }
}

/**
* checks to see if the tile is a potentially viewable hidden tile
*  if not, makes tile not visible
* ASSUMES YOU ARE NOT ON THE SEGMENT EDGE
*/
inline void enclosedTile(WorldSegment * segment, Tile* b)
{
    //make tiles that are impossible to see invisible
    if( b->designation.bits.hidden
        && (enclosed(segment, b)) ) {
            b->visible = false;
    }
}

/**
* enables visibility and disables fog for the first layer of water
*  below visible space
*/
inline void unhideWaterFromAbove(WorldSegment * segment, Tile * b)
{
    if( b->designation.bits.flow_size
        && !isTileOnTopOfSegment(segment, b)
        && (b->designation.bits.hidden || b->fog_of_war) ) {
            Tile * temp = segment->getTile(b->x, b->y, b->z+1);
            if( !temp || (!IDhasOpaqueFloor(temp->tileType) && !temp->designation.bits.flow_size) ) {
                if(contentLoader->gameMode.g_mode == GAMEMODE_ADVENTURE) {
                    if(!temp || !temp->fog_of_war) {
                        b->designation.bits.hidden = false;
                        b->fog_of_war = false;
                        if(b->building.info.type == BUILDINGTYPE_BLACKBOX) {
                            b->building.info.type = (building_type::building_type) BUILDINGTYPE_NA;
                        }
                    }
                } else {
                    if(!temp || !temp->designation.bits.hidden) {
                        b->designation.bits.hidden = false;
                        if(b->building.info.type == BUILDINGTYPE_BLACKBOX) {
                            b->building.info.type = (building_type::building_type) BUILDINGTYPE_NA;
                        }
                    }
                }
            }
    }
}

void beautify_Segment(WorldSegment * segment)
{
    if(!segment) {
        return;
    }

    clock_t starttime = clock();

    //do misc beautification

    uint32_t numtiles = segment->getNumTiles();

    for(uint32_t i=0; i < numtiles; i++) {
        Tile* b = segment->getTile(i);

        if(!b) {
            continue;
        }

        //try to mask away tiles that are flagged hidden
        if(!ssConfig.show_hidden_tiles ) {
            //unhide any liquids that are visible from above
            unhideWaterFromAbove(segment, b);
            if(ssConfig.shade_hidden_tiles) {
                maskTile(segment, b);
            } else if( b->designation.bits.hidden ) {
                b->visible = false;
            }
        }

        if(!b->visible) {
            continue;
        }

        if( !isTileOnVisibleEdgeOfSegment(segment, b) 
            && (b->tileType!=tiletype::OpenSpace
            || b->designation.bits.flow_size
            || b->creature
            || b->building.info.type != BUILDINGTYPE_NA
            || b->haseffect)) {

            //hide any tiles that are totally surrounded
            enclosedTile(segment, b);

            if(!b->visible) {
                continue;
            }

            //next see if the tile is behind something
            if(ssConfig.occlusion) {
                occlude_tile(b);
            }

            if(!b->visible) {
                continue;
            }
        }

        if(!ssConfig.show_hidden_tiles && b->designation.bits.hidden) {
            continue;
        }

        //Grass
        if(b->grasslevel > 0 && (
            (b->tileMaterial() == tiletype_material::GRASS_LIGHT) ||
            (b->tileMaterial() == tiletype_material::GRASS_DARK) ||
            (b->tileMaterial() == tiletype_material::GRASS_DEAD) ||
            (b->tileMaterial() == tiletype_material::GRASS_DRY))) {
                c_tile_tree * vegetationsprite = 0;
                vegetationsprite = getVegetationTree(contentLoader->grassConfigs,b->grassmat,true,true);
                if(vegetationsprite) {
                    vegetationsprite->insert_sprites(segment, b->x, b->y, b->z, b);
                }
        }

        //setup building sprites
        if( b->building.info.type != BUILDINGTYPE_NA && b->building.info.type != BUILDINGTYPE_BLACKBOX && b->building.info.type != BUILDINGTYPE_TREE) {
            loadBuildingSprites( b);
        }

        //populate trees
        if(b->tree.index) {
            c_tile_tree * Tree = GetTreeVegetation(b->tileShape(), b->tileSpecial(), b->tree.index );
            Tree->insert_sprites(segment, b->x, b->y, b->z, b);
        }


        //setup deep water
        if( b->designation.bits.flow_size == 7 && b->designation.bits.liquid_type == 0) {
            int topdepth = tileWaterDepth(b->x, b->y, b->z, segment, eAbove);
            if(topdepth) {
                b->deepwater = true;
            }
        }


        //setup ramps
        if(b->tileShapeBasic()==tiletype_shape_basic::Ramp) {
            b->rampindex = CalculateRampType(b->x, b->y, b->z, segment);
        }
        //add edges to tiles and floors

        Tile * dir1 = segment->getTileRelativeTo(b->x, b->y, b->z, eUpLeft);
        Tile * dir2 = segment->getTileRelativeTo(b->x, b->y, b->z, eUp);
        Tile * dir3 = segment->getTileRelativeTo(b->x, b->y, b->z, eUpRight);
        Tile * dir4 = segment->getTileRelativeTo(b->x, b->y, b->z, eRight);
        Tile * dir5 = segment->getTileRelativeTo(b->x, b->y, b->z, eDownRight);
        Tile * dir6 = segment->getTileRelativeTo(b->x, b->y, b->z, eDown);
        Tile * dir7 = segment->getTileRelativeTo(b->x, b->y, b->z, eDownLeft);
        Tile * dir8 = segment->getTileRelativeTo(b->x, b->y, b->z, eLeft);

        b->obscuringBuilding=0;
        b->obscuringCreature=0;

        if(dir1) if(dir1->occ.bits.unit) {
            b->obscuringCreature = 1;
        }
        if(dir2) if(dir2->occ.bits.unit) {
            b->obscuringCreature = 1;
        }
        if(dir8) if(dir8->occ.bits.unit) {
            b->obscuringCreature = 1;
        }

        if(dir1)
            if(dir1->building.info.type != BUILDINGTYPE_NA
                && dir1->building.info.type != BUILDINGTYPE_BLACKBOX
                && dir1->building.info.type != df::enums::building_type::Civzone
                && dir1->building.info.type != df::enums::building_type::Stockpile
                ) {
                    b->obscuringBuilding = 1;
            }
            if(dir2)
                if(dir2->building.info.type != BUILDINGTYPE_NA
                    && dir2->building.info.type != BUILDINGTYPE_BLACKBOX
                    && dir2->building.info.type != df::enums::building_type::Civzone
                    && dir2->building.info.type != df::enums::building_type::Stockpile
                    ) {
                        b->obscuringBuilding = 1;
                }
                if(dir8)
                    if(dir8->building.info.type != BUILDINGTYPE_NA
                        && dir8->building.info.type != BUILDINGTYPE_BLACKBOX
                        && dir8->building.info.type != df::enums::building_type::Civzone
                        && dir8->building.info.type != df::enums::building_type::Stockpile
                        ) {
                            b->obscuringBuilding = 1;
                    }

                    if( b->tileShapeBasic()==tiletype_shape_basic::Floor ) {
                        b->depthBorderWest = checkFloorBorderRequirement(segment, b->x, b->y, b->z, eLeft);
                        b->depthBorderNorth = checkFloorBorderRequirement(segment, b->x, b->y, b->z, eUp);

                        Tile* belowTile = segment->getTileRelativeTo(b->x, b->y, b->z, eBelow);
                        if(!belowTile || (belowTile->tileShapeBasic()!=tiletype_shape_basic::Wall && belowTile->tileShapeBasic()!=tiletype_shape_basic::Wall)) {
                            b->depthBorderDown = true;
                        }
                    } else if( b->tileShapeBasic()==tiletype_shape_basic::Wall && wallShouldNotHaveBorders( b->tileType ) == false ) {
                        Tile* leftTile = segment->getTileRelativeTo(b->x, b->y, b->z, eLeft);
                        Tile* upTile = segment->getTileRelativeTo(b->x, b->y, b->z, eUp);
                        if(!leftTile || (leftTile->tileShapeBasic()!=tiletype_shape_basic::Wall && leftTile->tileShapeBasic()!=tiletype_shape_basic::Ramp)) {
                            b->depthBorderWest = true;
                        }
                        if(!upTile || (upTile->tileShapeBasic()!=tiletype_shape_basic::Wall && upTile->tileShapeBasic()!=tiletype_shape_basic::Ramp)) {
                            b->depthBorderNorth = true;
                        }
                        Tile* belowTile = segment->getTileRelativeTo(b->x, b->y, b->z, eBelow);
                        if(!belowTile || (belowTile->tileShapeBasic()!=tiletype_shape_basic::Wall && belowTile->tileShapeBasic()!=tiletype_shape_basic::Ramp)) {
                            b->depthBorderDown = true;
                        }
                    }
                    b->wallborders = 0;
                    if(dir1) if(dir1->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 1;
                    }
                    if(dir2) if(dir2->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 2;
                    }
                    if(dir3) if(dir3->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 4;
                    }
                    if(dir4) if(dir4->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 8;
                    }
                    if(dir5) if(dir5->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 16;
                    }
                    if(dir6) if(dir6->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 32;
                    }
                    if(dir7) if(dir7->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 64;
                    }
                    if(dir8) if(dir8->tileShapeBasic()==tiletype_shape_basic::Wall) {
                        b->wallborders |= 128;
                    }

                    b->rampborders = 0;
                    if(dir1) if(dir1->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 1;
                    }
                    if(dir2) if(dir2->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 2;
                    }
                    if(dir3) if(dir3->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 4;
                    }
                    if(dir4) if(dir4->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 8;
                    }
                    if(dir5) if(dir5->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 16;
                    }
                    if(dir6) if(dir6->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 32;
                    }
                    if(dir7) if(dir7->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 64;
                    }
                    if(dir8) if(dir8->tileShapeBasic()==tiletype_shape_basic::Ramp) {
                        b->wallborders |= 128;
                    }

                    b->upstairborders = 0;
                    b->downstairborders = 0;
                    if(dir1) if(dir1->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 1;
                    }
                    if(dir2) if(dir2->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 2;
                    }
                    if(dir3) if(dir3->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 4;
                    }
                    if(dir4) if(dir4->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 8;
                    }
                    if(dir5) if(dir5->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 16;
                    }
                    if(dir6) if(dir6->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 32;
                    }
                    if(dir7) if(dir7->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 64;
                    }
                    if(dir8) if(dir8->tileShape() == tiletype_shape::STAIR_UP) {
                        b->upstairborders |= 128;
                    }

                    if(dir1) if(dir1->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 1;
                    }
                    if(dir2) if(dir2->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 2;
                    }
                    if(dir3) if(dir3->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 4;
                    }
                    if(dir4) if(dir4->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 8;
                    }
                    if(dir5) if(dir5->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 16;
                    }
                    if(dir6) if(dir6->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 32;
                    }
                    if(dir7) if(dir7->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 64;
                    }
                    if(dir8) if(dir8->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->upstairborders |= 128;
                    }

                    if(dir1) if(dir1->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 1;
                    }
                    if(dir2) if(dir2->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 2;
                    }
                    if(dir3) if(dir3->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 4;
                    }
                    if(dir4) if(dir4->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 8;
                    }
                    if(dir5) if(dir5->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 16;
                    }
                    if(dir6) if(dir6->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 32;
                    }
                    if(dir7) if(dir7->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 64;
                    }
                    if(dir8) if(dir8->tileShape() == tiletype_shape::STAIR_UPDOWN) {
                        b->downstairborders |= 128;
                    }

                    if(dir1) if(dir1->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 1;
                    }
                    if(dir2) if(dir2->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 2;
                    }
                    if(dir3) if(dir3->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 4;
                    }
                    if(dir4) if(dir4->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 8;
                    }
                    if(dir5) if(dir5->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 16;
                    }
                    if(dir6) if(dir6->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 32;
                    }
                    if(dir7) if(dir7->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 64;
                    }
                    if(dir8) if(dir8->tileShape() == tiletype_shape::STAIR_DOWN) {
                        b->downstairborders |= 128;
                    }

                    b->floorborders = 0;
                    if(dir1) if(dir1->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 1;
                    }
                    if(dir2) if(dir2->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 2;
                    }
                    if(dir3) if(dir3->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 4;
                    }
                    if(dir4) if(dir4->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 8;
                    }
                    if(dir5) if(dir5->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 16;
                    }
                    if(dir6) if(dir6->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 32;
                    }
                    if(dir7) if(dir7->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 64;
                    }
                    if(dir8) if(dir8->tileShapeBasic()==tiletype_shape_basic::Floor) {
                        b->floorborders |= 128;
                    }

                    b->lightborders = 0;
                    if(dir1) if(!dir1->designation.bits.outside) {
                        b->lightborders |= 1;
                    }
                    if(dir2) if(!dir2->designation.bits.outside) {
                        b->lightborders |= 2;
                    }
                    if(dir3) if(!dir3->designation.bits.outside) {
                        b->lightborders |= 4;
                    }
                    if(dir4) if(!dir4->designation.bits.outside) {
                        b->lightborders |= 8;
                    }
                    if(dir5) if(!dir5->designation.bits.outside) {
                        b->lightborders |= 16;
                    }
                    if(dir6) if(!dir6->designation.bits.outside) {
                        b->lightborders |= 32;
                    }
                    if(dir7) if(!dir7->designation.bits.outside) {
                        b->lightborders |= 64;
                    }
                    if(dir8) if(!dir8->designation.bits.outside) {
                        b->lightborders |= 128;
                    }
                    b->lightborders = ~b->lightborders;

                    b->openborders = ~(b->floorborders|b->rampborders|b->wallborders|b->downstairborders|b->upstairborders);
    }
    segment->processed = 1;
    ssTimers.beautify_time = (clock() - starttime)*0.1 + ssTimers.beautify_time*0.9;
}

void FollowCurrentDFWindow()
{
    int32_t newviewx;
    int32_t newviewy;
    int32_t viewsizex;
    int32_t viewsizey;
    int32_t newviewz;
    int32_t mapx, mapy, mapz;
    // we take the rectangle you'd get if you scrolled the DF view closely around
    // map edges with a pen pierced through the center,
    // compute the scaling factor between this rectangle and the map bounds and then scale
    // the coords with this scaling factor
    /**
    +---+
    |W+-++----------+
    +-+-+---------+ |
    | |         | |
    | | inner   | |
    | |   rect. | |
    | |         | |
    | |         | |--- map boundary
    | +---------+ |
    +-------------+  W - corrected view
    */
    Maps::getSize((uint32_t &)mapx, (uint32_t &)mapy, (uint32_t &)mapz);
    mapx *= 16;
    mapy *= 16;

    Gui::getWindowSize(viewsizex,viewsizey);
    float scalex = float (mapx) / float (mapx - viewsizex);
    float scaley = float (mapy) / float (mapy - viewsizey);

    Gui::getViewCoords(newviewx,newviewy,newviewz);
    newviewx = newviewx + (viewsizex / 2) - mapx / 2;
    newviewy = newviewy + (viewsizey / 2) - mapy / 2;

    parms.x = float (newviewx) * scalex - (ssConfig.segmentSize.x / 2) + ssConfig.viewXoffset + mapx / 2;
    parms.y = float (newviewy) * scaley - (ssConfig.segmentSize.y / 2) + ssConfig.viewYoffset + mapy / 2;
    parms.z = newviewz + ssConfig.viewZoffset + 1;
}

void FollowCurrentDFCenter()
{
    int32_t newviewx;
    int32_t newviewy;
    int32_t viewsizex;
    int32_t viewsizey;
    int32_t newviewz;
    Gui::getWindowSize(viewsizex,viewsizey);
    Gui::getViewCoords(newviewx,newviewy,newviewz);
    int screenx, screeny, screenz;
    ScreenToPoint(ssState.ScreenW/2, ssState.ScreenH/2, screenx, screeny, screenz);
    parms.x = newviewx + (viewsizex/2) - screenx + ssConfig.viewXoffset;
    parms.y = newviewy + (viewsizey/2) - screeny + ssConfig.viewYoffset;
    parms.z = newviewz + ssConfig.viewZoffset + 1;
}

void read_segment( void *arg)
{
    if(!Maps::IsValid()) {
        return;
    }
    static bool firstLoad = 1;
    ssConfig.threadstarted = 1;
    WorldSegment* segment = NULL;
    {
        CoreSuspender suspend;
        if (firstLoad || ssConfig.follow_DFscreen) {
            firstLoad = 0;
            if (ssConfig.track_center) {
                FollowCurrentDFCenter();
            } else {
                FollowCurrentDFWindow();
            }
        }
        map_segment.lockRead();
        segment = map_segment.getRead();
        readMapSegment(segment, parms.x, parms.y, parms.z,parms.sizex, parms.sizey, parms.sizez);
        ssConfig.threadstarted = 0;
    }

    if(segment) {
        beautify_Segment(segment);

        //putting these here to increase responsiveness of the UI and to make megashots work
        segment->displayed.x = ssState.DisplayedSegmentX;
        segment->displayed.y = ssState.DisplayedSegmentY;
        segment->displayed.z = ssState.DisplayedSegmentZ;

        //suspend DF to do the detailed read/draw
        {
            CoreSuspender suspend;
            segment->AssembleAllTiles();
        }

        map_segment.lockDraw();
        map_segment.swap();
        map_segment.unlock();
    }
}

static void * threadedSegment(ALLEGRO_THREAD *read_thread, void *arg)
{
    while(!al_get_thread_should_stop(read_thread)) {
        al_lock_mutex(ssConfig.readMutex);
        read_segment(arg);
        al_unlock_mutex(ssConfig.readMutex);
        al_rest(ssConfig.automatic_reload_time/1000.0);
    }
    return 0;
}

void reloadDisplayedSegment()
{
    //create handle to dfHack API
    static bool firstLoad = 1;

    if (timeToReloadConfig) {
        parms.thread_connect = 0;
        contentLoader->Load();
        timeToReloadConfig = false;
    }

    if (firstLoad || ssConfig.follow_DFscreen) {
        ssState.DisplayedSegmentX = parms.x;
        ssState.DisplayedSegmentY = parms.y;
        ssState.DisplayedSegmentZ = parms.z;
    }

    int segmentHeight = ssConfig.single_layer_view ? 2 : ssConfig.segmentSize.z;
    //load segment
    if(ssConfig.threading_enable) {
        if(!ssConfig.threadmade) {
            ssConfig.readThread = al_create_thread(threadedSegment, NULL);
            ssConfig.threadmade = 1;
        }
    }

    parms.x = ssState.DisplayedSegmentX;
    parms.y = ssState.DisplayedSegmentY;
    parms.z = ssState.DisplayedSegmentZ;
    parms.sizex = ssConfig.segmentSize.x;
    parms.sizey = ssConfig.segmentSize.y;
    parms.sizez = segmentHeight;

    if(ssConfig.threading_enable) {
        al_start_thread(ssConfig.readThread);
    } else {
        read_segment(NULL);
    }

    firstLoad = 0;
}
