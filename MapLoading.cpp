#include "common.h"
#include "GUI.h"
#include "MapLoading.h"
#include "WorldSegment.h"
#include "SpriteMaps.h"
#include "Constructions.h"
#include "GameBuildings.h"
#include "Creatures.h"
#include "ContentLoader.h"
#include "OcclusionTest.h"
#include <df/flow_info.h>
#include <df/plant.h>
#include <df/flow_info.h>
#include "df/item_constructed.h"
#include "df/itemimprovement.h"
#include "df/itemimprovement_threadst.h"
#include "df/item_threadst.h"

bool connected = 0;
bool threadrunnng = 0;
segParams parms;

//big look up table
char rampblut[] =
    // generated by blutmaker.py
{
    1 ,  2 ,  8 ,  2 ,  4 , 12 ,  4 , 12 ,  9 ,  2 , 21 ,  2 ,  4 , 12 ,  4 , 12 ,
    5 , 16 ,  5 , 16 , 13 , 13 , 13 , 12 ,  5 , 16 ,  5 , 16 , 13 , 13 , 13 , 16 ,
    7 ,  2 , 14 ,  2 ,  4 , 12 ,  4 , 12 , 20 , 26 , 25 , 26 ,  4 , 12 ,  4 , 12 ,
    5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,
    3 , 10 ,  3 , 10 , 17 , 12 , 17 , 12 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 10 , 11 , 16 , 11 , 26 , 17 , 12 , 11 , 16 , 11 , 16 , 13 , 13 , 17 , 16 ,
    3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 11 , 11 , 16 , 11 , 11 , 17 , 14 , 11 , 16 , 11 , 16 , 17 , 17 , 17 , 13 ,
    6 ,  2 , 19 ,  2 ,  4 , 12 ,  4 , 12 , 15 ,  2 , 24 ,  2 ,  4 , 12 ,  4 , 12 ,
    5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
    18 ,  2 , 22 ,  2 , 26 , 12 , 26 , 12 , 23 , 26 , 26 , 26 , 26 , 12 , 26 , 12 ,
    5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
    3 , 10 ,  3 , 10 , 17 , 10 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 10 , 11 , 16 , 17 , 10 , 17 , 17 , 11 , 16 , 11 , 16 , 17 , 15 , 17 , 12 ,
    3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
    11 , 16 , 11 , 16 , 17 , 16 , 17 , 10 , 11 , 16 , 11 , 16 , 17 , 11 , 17 , 26
};

inline bool isTileHighRampEnd(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
    Tile* tile = segment->getTileRelativeTo( x, y, z, dir);
    if(!tile) {
        return false;
    }
    if(tile->tileShapeBasic!=tiletype_shape_basic::Wall) {
        return false;
    }
    return IDisWall( tile->tileType );
}

inline int tileWaterDepth(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
    Tile* tile = segment->getTileRelativeTo( x, y, z, dir);
    if(!tile) {
        return false;
    }
    if(tile->water.index == 0 || tile->water.type == 1) {
        return false;
    }
    return tile->water.index;
}

inline bool isTileHighRampTop(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment, dirRelative dir)
{
    Tile* tile = segment->getTileRelativeTo( x, y, z, dir);
    if(!tile) {
        return false;
    }
    if(tile->tileShapeBasic!=tiletype_shape_basic::Floor && tile->tileShapeBasic!=tiletype_shape_basic::Ramp && tile->tileShapeBasic!=tiletype_shape_basic::Stair) {
        return false;
    }
    if(tile->tileShapeBasic!=tiletype_shape_basic::Wall) {
        return true;
    }
    return !IDisWall( tile->tileType );
}

inline bool isTileOnTopOfSegment(WorldSegment* segment, Tile* b)
{
    return b->z == segment->z + segment->sizez - 2;
}

int CalculateRampType(uint32_t x, uint32_t y, uint32_t z, WorldSegment* segment)
{
    int ramplookup = 0;
    if (isTileHighRampEnd(x, y, z, segment, eUp) && isTileHighRampTop(x, y, z+1, segment, eUp)) {
        ramplookup ^= 1;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpRight) && isTileHighRampTop(x, y, z+1, segment, eUpRight)) {
        ramplookup ^= 2;
    }
    if (isTileHighRampEnd(x, y, z, segment, eRight) && isTileHighRampTop(x, y, z+1, segment, eRight)) {
        ramplookup ^= 4;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownRight) && isTileHighRampTop(x, y, z+1, segment, eDownRight)) {
        ramplookup ^= 8;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDown) && isTileHighRampTop(x, y, z+1, segment, eDown)) {
        ramplookup ^= 16;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownLeft) && isTileHighRampTop(x, y, z+1, segment, eDownLeft)) {
        ramplookup ^= 32;
    }
    if (isTileHighRampEnd(x, y, z, segment, eLeft) && isTileHighRampTop(x, y, z+1, segment, eLeft)) {
        ramplookup ^= 64;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpLeft) && isTileHighRampTop(x, y, z+1, segment, eUpLeft)) {
        ramplookup ^= 128;
    }

    // creation should ensure in range
    if (ramplookup > 0) {
        return rampblut[ramplookup];
    }

    if (isTileHighRampEnd(x, y, z, segment, eUp)) {
        ramplookup ^= 1;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpRight)) {
        ramplookup ^= 2;
    }
    if (isTileHighRampEnd(x, y, z, segment, eRight)) {
        ramplookup ^= 4;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownRight)) {
        ramplookup ^= 8;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDown)) {
        ramplookup ^= 16;
    }
    if (isTileHighRampEnd(x, y, z, segment, eDownLeft)) {
        ramplookup ^= 32;
    }
    if (isTileHighRampEnd(x, y, z, segment, eLeft)) {
        ramplookup ^= 64;
    }
    if (isTileHighRampEnd(x, y, z, segment, eUpLeft)) {
        ramplookup ^= 128;
    }

    // creation should ensure in range
    return rampblut[ramplookup];
}

bool isTileOnVisibleEdgeOfSegment(WorldSegment* segment, Tile* b)
{
    if(b->z == segment->z + segment->sizez - 2) {
        return true;
    }

    if (ssState.DisplayedRotation == 0 &&
            (
                b->x == segment->x + segment->sizex - 2
                || b->y == segment->y + segment->sizey - 2
                || b->x == segment->regionSize.x - 1
                || b->y == segment->regionSize.y - 1
            )) {
        return true;
    } else if (ssState.DisplayedRotation == 1 &&
               (
                   b->x == segment->x + segment->sizex - 2
                   || b->y == segment->y + 1
                   || b->x == segment->regionSize.x - 1
                   || b->y == 0
               )) {
        return true;
    } else if (ssState.DisplayedRotation == 2 &&
               (
                   b->x == segment->x + 1
                   || b->y == segment->y + 1
                   || b->x == 0
                   || b->y == 0
               )) {
        return true;
    } else if (ssState.DisplayedRotation == 3 &&
               (
                   b->x == segment->x + 1
                   || b->y == segment->y + segment->sizey - 2
                   || b->x == 0
                   || b->y == segment->regionSize.y - 1
               )) {
        return true;
    }

    return false;
}

bool areNeighborsVisible(WorldSegment* segment, Tile* b)
{
    Tile* temp;

    temp = segment->getTile(b->x, b->y, b->z+1);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }

    temp = segment->getTile(b->x+1, b->y, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    temp = segment->getTile(b->x-1, b->y, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    temp = segment->getTile(b->x, b->y+1, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    temp = segment->getTile(b->x, b->y-1, b->z);
    if(!temp || !(temp->designation.bits.hidden)) {
        return true;
    }
    return false;
}

/**
* returns true iff the tile is enclosed by other solid tiles, and is itself solid
*/
bool enclosed(WorldSegment* segment, Tile* b)
{
    if(!IDisWall(b->tileType)) {
        return false;
    }

    Tile* temp;
    temp = segment->getTile(b->x, b->y, b->z+1);
    if(!temp || !IDhasOpaqueFloor(temp->tileType)) {
        return false;
    }

    temp = segment->getTile(b->x+1, b->y, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }
    temp = segment->getTile(b->x-1, b->y, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }
    temp = segment->getTile(b->x, b->y+1, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }
    temp = segment->getTile(b->x, b->y-1, b->z);
    if(!temp || !IDisWall(temp->tileType)) {
        return false;
    }

    return true;
}

void ReadBlockToSegment(DFHack::Core& DF, WorldSegment& segment, int BlockX, int BlockY, int BlockZ,
                       uint32_t BoundrySX, uint32_t BoundrySY,
                       uint32_t BoundryEX, uint32_t BoundryEY,
                       //uint16_t Flags/*not in use*/,
                       //vector<Buildings::t_building>* allBuildings,
                       //vector<df::construction>* allConstructions,
                       vector< vector <int16_t> >* allLayers)
{
    if(ssConfig.skipMaps) {
        return;
    }
    //boundry check
    int blockDimX, blockDimY, blockDimZ;
    Maps::getSize((unsigned int &)blockDimX, (unsigned int &)blockDimY, (unsigned int &)blockDimZ);
    if( BlockX < 0 || BlockX >= blockDimX ||
            BlockY < 0 || BlockY >= blockDimY ||
            BlockZ < 0 || BlockZ >= blockDimZ ) {
        return;
    }
    if(!Maps::getBlock(BlockX, BlockY, BlockZ)) {
        return;
    }


    //make boundries local
    BoundrySX -= BlockX * BLOCKEDGESIZE;
    BoundryEX -= BlockX * BLOCKEDGESIZE;
    BoundrySY -= BlockY * BLOCKEDGESIZE;
    BoundryEY -= BlockY * BLOCKEDGESIZE;


    //read block data
    df::map_block *trueBlock;
    trueBlock = Maps::getBlock(BlockX, BlockY, BlockZ);

    //read local vein data
    vector <df::block_square_event_mineralst * > veins;
    vector <df::block_square_event_frozen_liquidst * > ices;
    vector <df::block_square_event_material_spatterst * > splatter;
    vector <df::block_square_event_grassst * > grass;
    vector <df::block_square_event_world_constructionst * > worldconstructions;
    Maps::SortBlockEvents(
        trueBlock,
        &veins,
        &ices,
        &splatter,
        &grass,
        &worldconstructions);

    uint32_t numVeins = (uint32_t)veins.size();

    //parse block
    for(uint32_t ly = BoundrySY; ly <= BoundryEY; ly++) {
        for(uint32_t lx = BoundrySX; lx <= BoundryEX; lx++) {
            uint32_t gx = lx + (BlockX * BLOCKEDGESIZE);
            uint32_t gy = ly + (BlockY * BLOCKEDGESIZE);
            if( !segment.CoordinateInsideSegment( gx, gy, BlockZ) ) {
                continue;
            }
            bool createdTile = false;
            Tile* b = segment.getTile( gx, gy, BlockZ);

            if (!b) {
                createdTile = true;
                b = new Tile(&segment, df::tiletype::OpenSpace);
                b->x = gx;
                b->y = gy;
                b->z = BlockZ;
            }

            b->occ = trueBlock->occupancy[lx][ly];
            b->designation = trueBlock->designation[lx][ly];
            b->fog_of_war = !b->designation.bits.pile;
            b->mudlevel = 0;
            b->snowlevel = 0;
            b->bloodlevel = 0;
            b->grasslevel = 0;
            b->grassmat = -1;
            //b->grasslevels.clear();
            //b->grassmats.clear();
            for(int i = 0; i < grass.size(); i++) {
                if(grass[i]->amount[lx][ly] > 0 && b->grasslevel == 0) { //b->grasslevel)
                    b->grasslevel = grass[i]->amount[lx][ly];
                    b->grassmat = grass[i]->plant_index;
                    //b->grasslevels.push_back(grass[i].intensity[lx][ly]);
                    //b->grassmats.push_back(grass[i].material);
                }
            }
            if(1) { // just in case we need to quickly disable it.
                long red=0;
                long green=0;
                long blue=0;
                long bloodlevel=0;
                for(int i = 0; i < splatter.size(); i++) {
                    if(!splatter[i]->amount[lx][ly]) {
                        continue;
                    }
                    uint8_t level = (uint8_t)splatter[i]->amount[lx][ly];
                    if(splatter[i]->mat_type == MUD) {
                        b->mudlevel = level;
                    } else if(splatter[i]->mat_type == ICE) {
                        b->snowlevel = level;
                    } else if(splatter[i]->mat_type == VOMIT) {
                        bloodlevel += level;
                        red += (127 * level);
                        green += (196 * level);
                        blue += (28 *level);
                    } else if(splatter[i]->mat_type > 19) {
                        MaterialInfo mat;
                        mat.decode(splatter[i]->mat_type, splatter[i]->mat_index);
                        bloodlevel += level;
                        red += (contentLoader->Mats->color[mat.material->state_color[splatter[i]->mat_state]].red * level * 255);
                        green += (contentLoader->Mats->color[mat.material->state_color[splatter[i]->mat_state]].green * level * 255);
                        blue += (contentLoader->Mats->color[mat.material->state_color[splatter[i]->mat_state]].blue * level * 255);
                    }
                }
                if(bloodlevel < 0) {
                    bloodlevel = 0-bloodlevel;
                }
                b->bloodlevel = bloodlevel;
                if(bloodlevel) {
                    b->bloodcolor = al_map_rgba(red/b->bloodlevel, green/b->bloodlevel, blue/b->bloodlevel, (bloodlevel > ssConfig.bloodcutoff) ? 255 : bloodlevel*255/ssConfig.bloodcutoff);
                } else {
                    b->bloodcolor = al_map_rgba(0,0,0,0);
                }
            } else {
                b->bloodcolor = al_map_rgb(150, 0, 24);
            }
            //temperatures

            b->temp1 = trueBlock->temperature_1[lx][ly];
            b->temp2 = trueBlock->temperature_2[lx][ly];
            //liquids
            if(trueBlock->designation[lx][ly].bits.flow_size > 0) {
                b->water.type  = trueBlock->designation[lx][ly].bits.liquid_type;
                b->water.index = trueBlock->designation[lx][ly].bits.flow_size;
            }

            //read tiletype
            b->tileType = trueBlock->tiletype[lx][ly];
            b->tileShape = tileShape(b->tileType);
            b->tileShapeBasic = tileShapeBasic(b->tileShape);
            b->tileSpecial = tileSpecial(b->tileType);
            b->tileMaterial = tileMaterial(b->tileType);

            //check to see if the rest of the tile data is worth loading
            bool shouldBeIncluded = true;

            if(isOpenTerrain(b->tileType) && b->tileType != tiletype::RampTop) {
                if(ssConfig.show_hidden_tiles) {
                    shouldBeIncluded = false;
                } else if(!(b->designation.bits.hidden)) {
                    shouldBeIncluded = false;
                }
            } else if(!ssConfig.show_hidden_tiles
                      && b->designation.bits.hidden
                      && !ssConfig.shade_hidden_tiles) {
                shouldBeIncluded = false;
            }

            //add back in any liquid tiles, in case they can be seen from above
            if(b->water.index) {
                shouldBeIncluded = true;
            }

            if ( !shouldBeIncluded && createdTile ) {
                delete(b);
            } else if( shouldBeIncluded ) {
                //this only needs to be done for included tiles

                if (createdTile) {
                    segment.addTile(b);
                }

                //determine rock/soil type
                int rockIndex = -1;

                //first lookup the default geolayer for the location
                uint32_t tileBiomeIndex = trueBlock->designation[lx][ly].bits.biome;
                uint8_t tileRegionIndex = trueBlock->region_offset[tileBiomeIndex];
                uint32_t tileGeolayerIndex = trueBlock->designation[lx][ly].bits.geolayer_index;
                if(tileRegionIndex < (*allLayers).size()) {
                    if(tileGeolayerIndex < (*allLayers).at(tileRegionIndex).size()) {
                        rockIndex = (*allLayers).at(tileRegionIndex).at(tileGeolayerIndex);
                    }
                }
                

                bool soilTile = false;//is this tile a match for soil materials?
                bool soilMat = false;//is the material a soil?
                soilTile = b->tileMaterial == tiletype_material::SOIL
                    || (b->mudlevel == 0 
                        && (b->tileMaterial == tiletype_material::PLANT 
                            || b->tileMaterial == tiletype_material::GRASS_LIGHT
                            || b->tileMaterial == tiletype_material::GRASS_DARK
                            || b->tileMaterial == tiletype_material::GRASS_DRY
                            || b->tileMaterial == tiletype_material::GRASS_DEAD));
                if(b->tileMaterial == tiletype_material::STONE || soilTile) {

                    df::inorganic_raw * rawMat = df::inorganic_raw::find(rockIndex);
                    if(rawMat) {
                        soilMat = rawMat->flags.is_set(inorganic_flags::SOIL_ANY);
                        //if the tile is a stone tile but we got a soil material, we need to "dig down" to find it
                        while(!soilTile && soilMat) {
                            tileGeolayerIndex++;
                            if(tileGeolayerIndex < (*allLayers).at(tileRegionIndex).size()) {
                                rockIndex = (*allLayers).at(tileRegionIndex).at(tileGeolayerIndex);
                                rawMat = df::inorganic_raw::find(rockIndex);
                                if(rawMat) {
                                    soilMat = rawMat->flags.is_set(inorganic_flags::SOIL_ANY);
                                } else {
                                    rockIndex = -1;
                                    break;
                                }
                            } else {
                                rockIndex = -1;
                                break;
                            }
                        }
                        //if the tile is a soil tile but we got a stone material, we need to "dig up" to find it
                        while(soilTile && !soilMat) {
                            if(tileGeolayerIndex == 0) {
                                rockIndex = -1;
                                break;
                            }
                            tileGeolayerIndex--;
                            rockIndex = (*allLayers).at(tileRegionIndex).at(tileGeolayerIndex);
                            rawMat = df::inorganic_raw::find(rockIndex);
                            if(rawMat) {
                                soilMat = rawMat->flags.is_set(inorganic_flags::SOIL_ANY);

                            } else {
                                rockIndex = -1;
                                break;
                            }
                        }
                    } else {
                        rockIndex = -1;
                    }
                }

                b->layerMaterial.type = INORGANIC;
                b->layerMaterial.index = rockIndex;

                //check veins (defaults to layer material)
                b->veinMaterial.type = INORGANIC;
                b->veinMaterial.index = rockIndex;
                for(uint32_t i=0; i<numVeins; i++) {
                    uint16_t row = veins[i]->tile_bitmask[ly];
                    bool set = (row & (1 << lx)) != 0;
                    if(set) {
                        rockIndex = veins[i]->inorganic_mat;
                        b->veinMaterial.type = INORGANIC;
                        b->veinMaterial.index = veins[i]->inorganic_mat;
                        b->hasVein = 1;
                    } else {
                        b->veinMaterial.type = INORGANIC;
                        b->veinMaterial.index = rockIndex;
                    }
                }
                
                b->material.type = INORGANIC;
                if(soilTile) {
                    b->material.index = b->layerMaterial.index;
                } else { 
                    b->material.index = b->veinMaterial.index;
                }

                //read global/local features
                int16_t idx = trueBlock->global_feature;
                t_feature local, global;
                Maps::ReadFeatures(BlockX,BlockY,BlockZ,&local,&global);
                if( idx != -1 && global.type != -1 && global.main_material != -1) {
                    if(trueBlock->designation[lx][ly].bits.feature_global) {
                        b->layerMaterial.type = global.main_material;
                        b->layerMaterial.index = global.sub_material;
                        b->material.type = global.main_material;
                        b->material.index = global.sub_material;
                        b->hasVein = 0;
                    }
                }

                //read local features
                idx = trueBlock->local_feature;
                if( idx != -1 && local.type != -1 && local.main_material != -1 ) {
                    if(trueBlock->designation[lx][ly].bits.feature_local) {
                        b->veinMaterial.type = local.main_material;
                        b->veinMaterial.index = local.sub_material;
                        b->material.type = local.main_material;
                        b->material.index = local.sub_material;
                        b->hasVein = 1;
                    }
                }

                if(b->tileMaterial == tiletype_material::LAVA_STONE) {
                    b->material.type = INORGANIC;
                    b->material.index = contentLoader->obsidian;
                }
            }
        }
    }

    //add trees and other vegetation
    for(auto iter = trueBlock->plants.begin(); iter != trueBlock->plants.end(); iter++) {
        df::plant * wheat = *iter;
        assert(wheat != NULL);
        Tile* b = segment.getTile( wheat->pos.x, wheat->pos.y, wheat->pos.z);
        if(!b) {
            continue;
        }
        if( b->tileShape == tiletype_shape::TREE ||
                b->tileShape == tiletype_shape::SAPLING ||
                b->tileShape == tiletype_shape::SHRUB) {
            b->tree.type = wheat->flags.whole;
            b->tree.index = wheat->material;
        }
    }

    //add items
    for(auto iter = trueBlock->items.begin(); iter != trueBlock->items.end(); iter++) {
        int32_t item_index = *iter;
        df::item * found_item = df::item::find(item_index);
        if(!found_item) {
            continue;
        }
        Tile* b = segment.getTile( found_item->pos.x, found_item->pos.y, found_item->pos.z);
        if(!b) {
            continue;
        }
        b->Item.item.type = found_item->getType(); //itemtype
        b->Item.item.index = found_item->getSubtype(); //item subtype

        b->Item.matt.type = found_item->getActualMaterial();
        b->Item.matt.index = found_item->getActualMaterialIndex();

        if(1) { //found_item->isDyed())
            auto Constructed_Item = virtual_cast<df::item_constructed>(found_item);
            if(Constructed_Item) {
                for(int idex = 0; idex < Constructed_Item->improvements.size(); idex++) {
                    if(!Constructed_Item->improvements[idex]) {
                        continue;
                    }
                    if(Constructed_Item->improvements[idex]->getType() != improvement_type::THREAD) {
                        continue;
                    }
                    auto Improvement_Thread = virtual_cast<df::itemimprovement_threadst>(Constructed_Item->improvements[idex]);
                    if(!Improvement_Thread) {
                        continue;
                    }
                    if (Improvement_Thread->dye.mat_type < 0) {
                        break;
                    }
                    b->Item.dyematt.type = Improvement_Thread->dye.mat_type;
                    b->Item.dyematt.index = Improvement_Thread->dye.mat_index;
                }
            } else if (found_item->getType() == item_type::THREAD) {
                auto Thread_Item = virtual_cast<df::item_threadst>(found_item);
                if(!Thread_Item) {
                    break;
                }
                if (Thread_Item->dye_mat_type < 0) {
                    break;
                }
                b->Item.dyematt.type = Thread_Item->dye_mat_type;
                b->Item.dyematt.index = Thread_Item->dye_mat_index;
            }
        }
    }

    //add effects
    for(auto iter = trueBlock->flows.begin(); iter != trueBlock->flows.end(); iter++) {
        df::flow_info * eff = *iter;
        if(eff == NULL || eff->density <= 0) {
            continue;
        }
        Tile* b = segment.getTile( eff->pos.x, eff->pos.y, eff->pos.z);
        if(segment.CoordinateInsideSegment(eff->pos.x, eff->pos.y, eff->pos.z)) {
            if(!b) {
                b = new Tile(&segment, df::tiletype::OpenSpace);
                b->x=eff->pos.x;
                b->y=eff->pos.y;
                b->z=eff->pos.z;
                segment.addTile(b);
            }

        switch(eff->type) {
        case flow_type::Steam: {
            b->Eff_Steam.density += eff->density;
            b->Eff_Steam.matt.index = eff->mat_index;
            b->Eff_Steam.matt.type = eff->mat_type;
            break;
        }
        case flow_type::Mist: {
            b->Eff_Mist.density += eff->density;
            b->Eff_Mist.matt.index = eff->mat_index;
            b->Eff_Mist.matt.type = eff->mat_type;
            break;
        }
        case flow_type::MaterialDust: {
            b->Eff_MaterialDust.density += eff->density;
            b->Eff_MaterialDust.matt.index = eff->mat_index;
            b->Eff_MaterialDust.matt.type = eff->mat_type;
            break;
        }
        case flow_type::MagmaMist: {
            b->Eff_MagmaMist.density += eff->density;
            b->Eff_MagmaMist.matt.index = eff->mat_index;
            b->Eff_MagmaMist.matt.type = eff->mat_type;
            break;
        }
        case flow_type::Smoke: {
            b->Eff_Smoke.density += eff->density;
            b->Eff_Smoke.matt.index = eff->mat_index;
            b->Eff_Smoke.matt.type = eff->mat_type;
            break;
        }
        case flow_type::Dragonfire: {
            b->Eff_Dragonfire.density += eff->density;
            b->Eff_Dragonfire.matt.index = eff->mat_index;
            b->Eff_Dragonfire.matt.type = eff->mat_type;
            break;
        }
        case flow_type::Fire: {
            b->Eff_Fire.density += eff->density;
            b->Eff_Fire.matt.index = eff->mat_index;
            b->Eff_Fire.matt.type = eff->mat_type;
            break;
        }
        case flow_type::Web: {
            b->Eff_Web.density += eff->density;
            b->Eff_Web.matt.index = eff->mat_index;
            b->Eff_Web.matt.type = eff->mat_type;
            break;
        }
        case flow_type::MaterialGas: {
            b->Eff_MaterialGas.density += eff->density;
            b->Eff_MaterialGas.matt.index = eff->mat_index;
            b->Eff_MaterialGas.matt.type = eff->mat_type;
            break;
        }
        case flow_type::MaterialVapor: {
            b->Eff_MaterialVapor.density += eff->density;
            b->Eff_MaterialVapor.matt.index = eff->mat_index;
            b->Eff_MaterialVapor.matt.type = eff->mat_type;
            break;
        }
        case flow_type::OceanWave: {
            b->Eff_OceanWave.density += eff->density;
            b->Eff_OceanWave.matt.index = eff->mat_index;
            b->Eff_OceanWave.matt.type = eff->mat_type;
            break;
        }
        case flow_type::SeaFoam: {
            b->Eff_SeaFoam.density += eff->density;
            b->Eff_SeaFoam.matt.index = eff->mat_index;
            b->Eff_SeaFoam.matt.type = eff->mat_type;
            break;
        }
        }
        } 
    }
}


bool checkFloorBorderRequirement(WorldSegment* segment, int x, int y, int z, dirRelative offset)
{
    Tile* bHigh = segment->getTileRelativeTo(x, y, z, offset);
    if (bHigh && (bHigh->tileShapeBasic==tiletype_shape_basic::Floor || bHigh->tileShapeBasic==tiletype_shape_basic::Ramp || bHigh->tileShapeBasic==tiletype_shape_basic::Wall)) {
        return false;
    }
    Tile* bLow = segment->getTileRelativeTo(x, y, z-1, offset);
    if (bLow == NULL || bLow->tileShapeBasic!=tiletype_shape_basic::Ramp) {
        return true;
    }
    return false;
}


WorldSegment* ReadMapSegment(int x, int y, int z, int sizex, int sizey, int sizez)
{
    uint32_t index;
    clock_t starttime = clock();
    DFHack::Core & DF = Core::getInstance();

    //read date
    if(!ssConfig.skipWorld) {
        contentLoader->currentYear = World::ReadCurrentYear();
        contentLoader->currentTick = World::ReadCurrentTick();
        contentLoader->currentMonth = (contentLoader->currentTick+9)/33600;
        contentLoader->currentDay = ((contentLoader->currentTick+9)%33600)/1200;
        contentLoader->currentHour = ((contentLoader->currentTick+9)-(((contentLoader->currentMonth*28)+contentLoader->currentDay)*1200))/50;
        contentLoader->currentTickRel = (contentLoader->currentTick+9)-(((((contentLoader->currentMonth*28)+contentLoader->currentDay)*24)+contentLoader->currentHour)*50);
        World::ReadGameMode(contentLoader->gameMode);
    }

    if(ssConfig.skipMaps || !Maps::IsValid()) {
        return new WorldSegment(x,y,z + 1,sizex,sizey,sizez + 1);
    }

    //Read Number of blocks
    uint32_t blockDimX, blockDimY, blockDimZ;
    Maps::getSize(blockDimX, blockDimY, blockDimZ);
    //Read position of blocks
    uint32_t regionX, regionY, regionZ;
    Maps::getSize(regionX, regionY, regionZ);
    //Store these
    blockDimX *= BLOCKEDGESIZE;
    blockDimY *= BLOCKEDGESIZE;
    regionX *= BLOCKEDGESIZE;
    regionY *= BLOCKEDGESIZE;
    ssConfig.blockDimX = blockDimX;
    ssConfig.blockDimY = blockDimY;
    ssConfig.blockDimZ = blockDimZ;

    //setup new world segment
    WorldSegment* segment = new WorldSegment(x,y,z,sizex,sizey,sizez);
    segment->regionSize.x = blockDimX;
    segment->regionSize.y = blockDimY;
    segment->regionSize.z = blockDimZ;
    segment->regionPos.x = regionX;
    segment->regionPos.y = regionY;
    segment->regionPos.z = regionZ;
    segment->rotation = ssState.DisplayedRotation;

    //read world wide buildings
    vector<Buildings::t_building> allBuildings;
    if(!ssConfig.skipBuildings) {
        ReadBuildings(DF, &allBuildings);
    }

    /*if(GroundMaterialNamesTranslatedFromGame == false)
    TranslateGroundMaterialNames();*/

    // get region geology
    vector< vector <int16_t> > layers;
    vector<df::coord2d> geoidx;
    if(!Maps::ReadGeology( &layers, &geoidx )) {
        LogError("Can't get region geology.\n");
    }

    //read cursor
    Gui::getCursorCoords(ssConfig.dfCursorX, ssConfig.dfCursorY, ssConfig.dfCursorZ);

    // read constructions
    vector<df::construction> allConstructions;
    uint32_t numconstructions = 0;

    if(!ssConfig.skipConstructions) {
        numconstructions = Constructions::getCount();
        if (numconstructions) {
            df::construction tempcon;
            index = 0;
            while(index < numconstructions) {
                tempcon = *Constructions::getConstruction(index);
                if(segment->CoordinateInsideSegment(tempcon.pos.x, tempcon.pos.y, tempcon.pos.z)) {
                    allConstructions.push_back(tempcon);
                }
                index++;
            }
        }
    }

    //merge buildings with segment
    if(!ssConfig.skipBuildings) {
        MergeBuildingsToSegment(&allBuildings, segment);
    }

    //figure out what blocks to read
    int32_t firstTileToReadX = x;
    if( firstTileToReadX < 0 ) {
        firstTileToReadX = 0;
    }

    while(firstTileToReadX < x + sizex) {
        int blockx = firstTileToReadX / BLOCKEDGESIZE;
        int32_t lastTileInBlockX = (blockx+1) * BLOCKEDGESIZE - 1;
        int32_t lastTileToReadX = min<int32_t>(lastTileInBlockX, x+sizex-1);

        int32_t firstTileToReadY = y;
        if( firstTileToReadY < 0 ) {
            firstTileToReadY = 0;
        }

        while(firstTileToReadY < y + sizey) {
            int blocky = firstTileToReadY / BLOCKEDGESIZE;
            int32_t lastTileInBlockY = (blocky+1) * BLOCKEDGESIZE - 1;
            int32_t lastTileToReadY = min<uint32_t>(lastTileInBlockY, y+sizey-1);

            for(int lz=z-sizez; lz <= z; lz++) {
                //load the tiles from this block to the map segment
                ReadBlockToSegment(DF, *segment, blockx, blocky, lz,
                                  firstTileToReadX, firstTileToReadY, 
                                  lastTileToReadX, lastTileToReadY, &layers );

            }
            firstTileToReadY = lastTileToReadY + 1;
        }
        firstTileToReadX = lastTileToReadX + 1;
    }

    //translate constructions
    changeConstructionMaterials(segment, &allConstructions);

    uint32_t numengravings = Engravings::getCount();
    df::engraving * engraved;
    index = 0;
    Tile * b = 0;
    while(index < numengravings) {
        engraved = Engravings::getEngraving(index);
        df::coord pos = engraved->pos;
        if(segment->CoordinateInsideSegment(pos.x, pos.y, pos.z)) {
            b = segment->getTile(pos.x, pos.y, pos.z);
            if(!b) {
                continue;
            }
            b->engraving_character = engraved->tile;
            b->engraving_flags = engraved->flags;
            b->engraving_quality = engraved->quality;
        }
        index++;
    }
    
    //Read Creatures
    if(!ssConfig.skipCreatures) {
        ReadCreaturesToSegment( DF, segment );
    }

    segment->loaded = 1;
    ssTimers.read_time = (clock() - starttime)*0.1 + ssTimers.read_time*0.9;

    segment->processed = 0;

    return segment;
}

/**
* checks to see if the tile is a potentially viewable hidden tile
*  if so, put the black mask tile overtop
*  if not, makes tile not visible
*/
inline void maskTile(WorldSegment * segment, Tile* b)
{
    //include hidden tiles as shaded black, make remaining invisible
    if( b->designation.bits.hidden ) {
        if( isTileOnVisibleEdgeOfSegment(segment, b)
                || areNeighborsVisible(segment, b) ) {
            b->building.info.type = (building_type::building_type) BUILDINGTYPE_BLACKBOX;
        } else {
            b->visible = false;
        }
    }
}

/**
* checks to see if the tile is a potentially viewable hidden tile
*  if not, makes tile not visible
* ASSUMES YOU ARE NOT ON THE SEGMENT EDGE
*/
inline void enclosedTile(WorldSegment * segment, Tile* b)
{
    //make tiles that are impossible to see invisible
    if( b->designation.bits.hidden
            && (enclosed(segment, b)) ) {
        b->visible = false;
    }
}

/**
* enables visibility and disables fog for the first layer of water
*  below visible space
*/
inline void unhideWaterFromAbove(WorldSegment * segment, Tile * b)
{
    if( b->water.index
            && !isTileOnTopOfSegment(segment, b)
            && (b->designation.bits.hidden || b->fog_of_war) ) {
        Tile * temp = segment->getTile(b->x, b->y, b->z+1);
        if( !temp || (!IDhasOpaqueFloor(temp->tileType) && !temp->water.index) ) {
            if(contentLoader->gameMode.g_mode == GAMEMODE_ADVENTURE) {
                if(!temp || !temp->fog_of_war) {
                    b->designation.bits.hidden = false;
                    b->fog_of_war = false;
                    if(b->building.info.type == BUILDINGTYPE_BLACKBOX) {
                        b->building.info.type = (building_type::building_type) BUILDINGTYPE_NA;
                    }
                }
            } else {
                if(!temp || !temp->designation.bits.hidden) {
                    b->designation.bits.hidden = false;
                    if(b->building.info.type == BUILDINGTYPE_BLACKBOX) {
                        b->building.info.type = (building_type::building_type) BUILDINGTYPE_NA;
                    }
                }
            }
        }
    }
}

void beautify_Segment(WorldSegment * segment)
{
    if(!segment) {
        return;
    }

    clock_t starttime = clock();

    //do misc beautification

    uint32_t numtiles = segment->getNumTiles();

    for(uint32_t i=0; i < numtiles; i++) {
        Tile* b = segment->getTile(i);

        //try to mask away tiles that are flagged hidden
        if(!ssConfig.show_hidden_tiles ) {
            //unhide any liquids that are visible from above
            unhideWaterFromAbove(segment, b);
            if(ssConfig.shade_hidden_tiles) {
                maskTile(segment, b);
            } else if( b->designation.bits.hidden ) {
                b->visible = false;
            }
        }

        if(!b->visible) {
            continue;
        }

        if( !isTileOnVisibleEdgeOfSegment(segment, b) ) {

            //hide any tiles that are totally surrounded
            enclosedTile(segment, b);

            if(!b->visible) {
                continue;
            }

            //next see if the tile is behind something
            if(ssConfig.occlusion) {
                occlude_tile(b);
            }

            if(!b->visible) {
                continue;
            }
        }

        //Grass
        if(b->grasslevel > 0 && (
                    (b->tileMaterial == tiletype_material::GRASS_LIGHT) ||
                    (b->tileMaterial == tiletype_material::GRASS_DARK) ||
                    (b->tileMaterial == tiletype_material::GRASS_DEAD) ||
                    (b->tileMaterial == tiletype_material::GRASS_DRY))) {
            c_tile_tree * vegetationsprite = 0;
            vegetationsprite = getVegetationTree(contentLoader->grassConfigs,b->grassmat,true,true);
            if(vegetationsprite) {
                vegetationsprite->insert_sprites(segment, b->x, b->y, b->z, b);
            }
        }

        //setup building sprites
        if( b->building.info.type != BUILDINGTYPE_NA && b->building.info.type != BUILDINGTYPE_BLACKBOX && b->building.info.type != BUILDINGTYPE_TREE) {
            loadBuildingSprites( b);
        }

        //populate trees
        if(b->tree.index) {
            c_tile_tree * Tree = GetTreeVegetation(b->tileShape, b->tileSpecial, b->tree.index );
            Tree->insert_sprites(segment, b->x, b->y, b->z, b);
        }


        //setup deep water
        if( b->water.index == 7 && b->water.type == 0) {
            int topdepth = tileWaterDepth(b->x, b->y, b->z, segment, eAbove);
            if(topdepth) {
                b->water.index = 8;
            }
        }


        //setup ramps
        if(b->tileShapeBasic==tiletype_shape_basic::Ramp) {
            b->ramp.index = CalculateRampType(b->x, b->y, b->z, segment);
        }
        //add edges to tiles and floors

        Tile * dir1 = segment->getTileRelativeTo(b->x, b->y, b->z, eUpLeft);
        Tile * dir2 = segment->getTileRelativeTo(b->x, b->y, b->z, eUp);
        Tile * dir3 = segment->getTileRelativeTo(b->x, b->y, b->z, eUpRight);
        Tile * dir4 = segment->getTileRelativeTo(b->x, b->y, b->z, eRight);
        Tile * dir5 = segment->getTileRelativeTo(b->x, b->y, b->z, eDownRight);
        Tile * dir6 = segment->getTileRelativeTo(b->x, b->y, b->z, eDown);
        Tile * dir7 = segment->getTileRelativeTo(b->x, b->y, b->z, eDownLeft);
        Tile * dir8 = segment->getTileRelativeTo(b->x, b->y, b->z, eLeft);

        b->obscuringBuilding=0;
        b->obscuringCreature=0;

        if(dir1) if(dir1->creaturePresent) {
                b->obscuringCreature = 1;
            }
        if(dir2) if(dir2->creaturePresent) {
                b->obscuringCreature = 1;
            }
        if(dir8) if(dir8->creaturePresent) {
                b->obscuringCreature = 1;
            }

        if(dir1)
            if(dir1->building.info.type != BUILDINGTYPE_NA
                    && dir1->building.info.type != BUILDINGTYPE_BLACKBOX
                    && dir1->building.info.type != df::enums::building_type::Civzone
                    && dir1->building.info.type != df::enums::building_type::Stockpile
              ) {
                b->obscuringBuilding = 1;
            }
        if(dir2)
            if(dir2->building.info.type != BUILDINGTYPE_NA
                    && dir2->building.info.type != BUILDINGTYPE_BLACKBOX
                    && dir2->building.info.type != df::enums::building_type::Civzone
                    && dir2->building.info.type != df::enums::building_type::Stockpile
              ) {
                b->obscuringBuilding = 1;
            }
        if(dir8)
            if(dir8->building.info.type != BUILDINGTYPE_NA
                    && dir8->building.info.type != BUILDINGTYPE_BLACKBOX
                    && dir8->building.info.type != df::enums::building_type::Civzone
                    && dir8->building.info.type != df::enums::building_type::Stockpile
              ) {
                b->obscuringBuilding = 1;
            }

        if( b->tileShapeBasic==tiletype_shape_basic::Floor ) {
            b->depthBorderWest = checkFloorBorderRequirement(segment, b->x, b->y, b->z, eLeft);
            b->depthBorderNorth = checkFloorBorderRequirement(segment, b->x, b->y, b->z, eUp);

            Tile* belowTile = segment->getTileRelativeTo(b->x, b->y, b->z, eBelow);
            if(!belowTile || (belowTile->tileShapeBasic!=tiletype_shape_basic::Wall && belowTile->tileShapeBasic!=tiletype_shape_basic::Wall)) {
                b->depthBorderDown = true;
            }
        } else if( b->tileShapeBasic==tiletype_shape_basic::Wall && wallShouldNotHaveBorders( b->tileType ) == false ) {
            Tile* leftTile = segment->getTileRelativeTo(b->x, b->y, b->z, eLeft);
            Tile* upTile = segment->getTileRelativeTo(b->x, b->y, b->z, eUp);
            if(!leftTile || (leftTile->tileShapeBasic!=tiletype_shape_basic::Wall && leftTile->tileShapeBasic!=tiletype_shape_basic::Ramp)) {
                b->depthBorderWest = true;
            }
            if(!upTile || (upTile->tileShapeBasic!=tiletype_shape_basic::Wall && upTile->tileShapeBasic!=tiletype_shape_basic::Ramp)) {
                b->depthBorderNorth = true;
            }
            Tile* belowTile = segment->getTileRelativeTo(b->x, b->y, b->z, eBelow);
            if(!belowTile || (belowTile->tileShapeBasic!=tiletype_shape_basic::Wall && belowTile->tileShapeBasic!=tiletype_shape_basic::Ramp)) {
                b->depthBorderDown = true;
            }
        }
        b->wallborders = 0;
        if(dir1) if(dir1->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 1;
            }
        if(dir2) if(dir2->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 2;
            }
        if(dir3) if(dir3->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 4;
            }
        if(dir4) if(dir4->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 8;
            }
        if(dir5) if(dir5->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 16;
            }
        if(dir6) if(dir6->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 32;
            }
        if(dir7) if(dir7->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 64;
            }
        if(dir8) if(dir8->tileShapeBasic==tiletype_shape_basic::Wall) {
                b->wallborders |= 128;
            }

        b->rampborders = 0;
        if(dir1) if(dir1->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 1;
            }
        if(dir2) if(dir2->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 2;
            }
        if(dir3) if(dir3->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 4;
            }
        if(dir4) if(dir4->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 8;
            }
        if(dir5) if(dir5->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 16;
            }
        if(dir6) if(dir6->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 32;
            }
        if(dir7) if(dir7->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 64;
            }
        if(dir8) if(dir8->tileShapeBasic==tiletype_shape_basic::Ramp) {
                b->wallborders |= 128;
            }

        b->upstairborders = 0;
        b->downstairborders = 0;
        if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 1;
            }
        if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 2;
            }
        if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 4;
            }
        if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 8;
            }
        if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 16;
            }
        if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 32;
            }
        if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 64;
            }
        if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_UP) {
                b->upstairborders |= 128;
            }

        if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 1;
            }
        if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 2;
            }
        if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 4;
            }
        if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 8;
            }
        if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 16;
            }
        if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 32;
            }
        if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 64;
            }
        if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->upstairborders |= 128;
            }

        if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 1;
            }
        if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 2;
            }
        if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 4;
            }
        if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 8;
            }
        if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 16;
            }
        if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 32;
            }
        if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 64;
            }
        if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_UPDOWN) {
                b->downstairborders |= 128;
            }

        if(dir1) if(dir1->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 1;
            }
        if(dir2) if(dir2->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 2;
            }
        if(dir3) if(dir3->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 4;
            }
        if(dir4) if(dir4->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 8;
            }
        if(dir5) if(dir5->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 16;
            }
        if(dir6) if(dir6->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 32;
            }
        if(dir7) if(dir7->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 64;
            }
        if(dir8) if(dir8->tileShape == tiletype_shape::STAIR_DOWN) {
                b->downstairborders |= 128;
            }

        b->floorborders = 0;
        if(dir1) if(dir1->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 1;
            }
        if(dir2) if(dir2->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 2;
            }
        if(dir3) if(dir3->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 4;
            }
        if(dir4) if(dir4->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 8;
            }
        if(dir5) if(dir5->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 16;
            }
        if(dir6) if(dir6->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 32;
            }
        if(dir7) if(dir7->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 64;
            }
        if(dir8) if(dir8->tileShapeBasic==tiletype_shape_basic::Floor) {
                b->floorborders |= 128;
            }

        b->lightborders = 0;
        if(dir1) if(!dir1->designation.bits.outside) {
                b->lightborders |= 1;
            }
        if(dir2) if(!dir2->designation.bits.outside) {
                b->lightborders |= 2;
            }
        if(dir3) if(!dir3->designation.bits.outside) {
                b->lightborders |= 4;
            }
        if(dir4) if(!dir4->designation.bits.outside) {
                b->lightborders |= 8;
            }
        if(dir5) if(!dir5->designation.bits.outside) {
                b->lightborders |= 16;
            }
        if(dir6) if(!dir6->designation.bits.outside) {
                b->lightborders |= 32;
            }
        if(dir7) if(!dir7->designation.bits.outside) {
                b->lightborders |= 64;
            }
        if(dir8) if(!dir8->designation.bits.outside) {
                b->lightborders |= 128;
            }
        b->lightborders = ~b->lightborders;

        b->openborders = ~(b->floorborders|b->rampborders|b->wallborders|b->downstairborders|b->upstairborders);
    }
    segment->processed = 1;
    ssTimers.beautify_time = (clock() - starttime)*0.1 + ssTimers.beautify_time*0.9;
}

void FollowCurrentDFWindow()
{
    int32_t newviewx;
    int32_t newviewy;
    int32_t viewsizex;
    int32_t viewsizey;
    int32_t newviewz;
    int32_t mapx, mapy, mapz;
    // we take the rectangle you'd get if you scrolled the DF view closely around
    // map edges with a pen pierced through the center,
    // compute the scaling factor between this rectangle and the map bounds and then scale
    // the coords with this scaling factor
    /**
    +---+
    |W+-++----------+
    +-+-+---------+ |
    | |         | |
    | | inner   | |
    | |   rect. | |
    | |         | |
    | |         | |--- map boundary
    | +---------+ |
    +-------------+  W - corrected view
    */
    Maps::getSize((uint32_t &)mapx, (uint32_t &)mapy, (uint32_t &)mapz);
    mapx *= 16;
    mapy *= 16;

    Gui::getWindowSize(viewsizex,viewsizey);
    float scalex = float (mapx) / float (mapx - viewsizex);
    float scaley = float (mapy) / float (mapy - viewsizey);

    Gui::getViewCoords(newviewx,newviewy,newviewz);
    newviewx = newviewx + (viewsizex / 2) - mapx / 2;
    newviewy = newviewy + (viewsizey / 2) - mapy / 2;

    parms.x = float (newviewx) * scalex - (ssConfig.segmentSize.x / 2) + ssConfig.viewXoffset + mapx / 2;
    parms.y = float (newviewy) * scaley - (ssConfig.segmentSize.y / 2) + ssConfig.viewYoffset + mapy / 2;
    parms.z = newviewz + ssConfig.viewZoffset + 1;
}

void FollowCurrentDFCenter()
{
    int32_t newviewx;
    int32_t newviewy;
    int32_t viewsizex;
    int32_t viewsizey;
    int32_t newviewz;
    Gui::getWindowSize(viewsizex,viewsizey);
    Gui::getViewCoords(newviewx,newviewy,newviewz);
    int screenx, screeny, screenz;
    ScreenToPoint(ssState.ScreenW/2, ssState.ScreenH/2, screenx, screeny, screenz);
    parms.x = newviewx + (viewsizex/2) - screenx + ssConfig.viewXoffset;
    parms.y = newviewy + (viewsizey/2) - screeny + ssConfig.viewYoffset;
    parms.z = newviewz + ssConfig.viewZoffset + 1;
}

void read_segment( void *arg)
{
    if(!Maps::IsValid()) {
        return;
    }
    static bool firstLoad = 1;
    ssConfig.threadstarted = 1;
    WorldSegment * segment = 0;
    // Suspended tile
    {
        CoreSuspender suspend;
        if (firstLoad || ssConfig.follow_DFscreen) {
            firstLoad = 0;
            if (ssConfig.track_center) {
                FollowCurrentDFCenter();
            } else {
                FollowCurrentDFWindow();
            }
        }
        segment = ReadMapSegment(parms.x, parms.y, parms.z,parms.sizex, parms.sizey, parms.sizez);
        ssConfig.threadstarted = 0;
    }

    if(segment) {
        beautify_Segment(segment);
        
        //putting these here to increase responsiveness of the UI and to make megashots work
        segment->displayedx = ssState.DisplayedSegmentX;
        segment->displayedy = ssState.DisplayedSegmentY;
        segment->displayedz = ssState.DisplayedSegmentZ;

        segment->AssembleAllTiles();
    }

    map_segment.lock();
    WorldSegment* old_segment = map_segment.swap(segment);
    map_segment.unlock();
    if(old_segment) {
        old_segment->Dispose();
        delete old_segment;
    }
}

static void * threadedSegment(ALLEGRO_THREAD *read_thread, void *arg)
{
    while(!al_get_thread_should_stop(read_thread)) {
        al_lock_mutex(ssConfig.readMutex);
        read_segment(arg);
        al_unlock_mutex(ssConfig.readMutex);
        al_rest(ssConfig.automatic_reload_time/1000.0);
    }
    return 0;
}

void reloadDisplayedSegment()
{
    //create handle to dfHack API
    static bool firstLoad = 1;

    if (timeToReloadConfig) {
        parms.thread_connect = 0;
        contentLoader->Load();
        timeToReloadConfig = false;
    }

    if (firstLoad || ssConfig.follow_DFscreen) {
        ssState.DisplayedSegmentX = parms.x;
        ssState.DisplayedSegmentY = parms.y;
        ssState.DisplayedSegmentZ = parms.z;
    }

    int segmentHeight = ssConfig.single_layer_view ? 2 : ssConfig.segmentSize.z;
    //load segment
    if(ssConfig.threading_enable) {
        if(!ssConfig.threadmade) {
            ssConfig.readThread = al_create_thread(threadedSegment, NULL);
            ssConfig.threadmade = 1;
        }
    }

    parms.x = ssState.DisplayedSegmentX;
    parms.y = ssState.DisplayedSegmentY;
    parms.z = ssState.DisplayedSegmentZ;
    parms.sizex = ssConfig.segmentSize.x;
    parms.sizey = ssConfig.segmentSize.y;
    parms.sizez = segmentHeight;

    if(ssConfig.threading_enable) {
        al_start_thread(ssConfig.readThread);
    } else {
        read_segment(NULL);
    }

    firstLoad = 0;
}
